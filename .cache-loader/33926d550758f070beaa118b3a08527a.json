{"remainingRequest":"/Users/jeffrey/HaulTesting/node_modules/thread-loader/dist/cjs.js??ref--5-1!/Users/jeffrey/HaulTesting/node_modules/babel-loader/lib/index.js??ref--5-2!/Users/jeffrey/HaulTesting/node_modules/react-native/Libraries/Components/ScrollResponder.js","dependencies":[{"path":"/Users/jeffrey/HaulTesting/node_modules/react-native/Libraries/Components/ScrollResponder.js","mtime":1539700108130},{"path":"/Users/jeffrey/HaulTesting/node_modules/cache-loader/dist/cjs.js","mtime":1539652983212},{"path":"/Users/jeffrey/HaulTesting/node_modules/thread-loader/dist/cjs.js","mtime":1539652983315},{"path":"/Users/jeffrey/HaulTesting/node_modules/babel-loader/lib/index.js","mtime":1539615827828}],"contextDependencies":[],"result":["'use strict';(function(){var enterModule=require('react-hot-loader').enterModule;enterModule&&enterModule(module);})();var Dimensions=require('Dimensions');var FrameRateLogger=require('FrameRateLogger');var Keyboard=require('Keyboard');var ReactNative=require('ReactNative');var Subscribable=require('Subscribable');var TextInputState=require('TextInputState');var UIManager=require('UIManager');var invariant=require('fbjs/lib/invariant');var nullthrows=require('fbjs/lib/nullthrows');var performanceNow=require('fbjs/lib/performanceNow');var warning=require('fbjs/lib/warning');var _require=require('NativeModules'),ScrollViewManager=_require.ScrollViewManager;var IS_ANIMATING_TOUCH_START_THRESHOLD_MS=16;var ScrollResponderMixin={mixins:[Subscribable.Mixin],scrollResponderMixinGetInitialState:function scrollResponderMixinGetInitialState(){return{isTouching:false,lastMomentumScrollBeginTime:0,lastMomentumScrollEndTime:0,observedScrollSinceBecomingResponder:false,becameResponderWhileAnimating:false};},scrollResponderHandleScrollShouldSetResponder:function scrollResponderHandleScrollShouldSetResponder(){return this.state.isTouching;},scrollResponderHandleStartShouldSetResponder:function scrollResponderHandleStartShouldSetResponder(e){var currentlyFocusedTextInput=TextInputState.currentlyFocusedField();if(this.props.keyboardShouldPersistTaps==='handled'&&currentlyFocusedTextInput!=null&&e.target!==currentlyFocusedTextInput){return true;}return false;},scrollResponderHandleStartShouldSetResponderCapture:function scrollResponderHandleStartShouldSetResponderCapture(e){if(this.scrollResponderIsAnimating()){return true;}var currentlyFocusedTextInput=TextInputState.currentlyFocusedField();var keyboardShouldPersistTaps=this.props.keyboardShouldPersistTaps;var keyboardNeverPersistTaps=!keyboardShouldPersistTaps||keyboardShouldPersistTaps==='never';if(keyboardNeverPersistTaps&&currentlyFocusedTextInput!=null&&!TextInputState.isTextInput(e.target)){return true;}return false;},scrollResponderHandleResponderReject:function scrollResponderHandleResponderReject(){},scrollResponderHandleTerminationRequest:function scrollResponderHandleTerminationRequest(){return!this.state.observedScrollSinceBecomingResponder;},scrollResponderHandleTouchEnd:function scrollResponderHandleTouchEnd(e){var nativeEvent=e.nativeEvent;this.state.isTouching=nativeEvent.touches.length!==0;this.props.onTouchEnd&&this.props.onTouchEnd(e);},scrollResponderHandleTouchCancel:function scrollResponderHandleTouchCancel(e){this.state.isTouching=false;this.props.onTouchCancel&&this.props.onTouchCancel(e);},scrollResponderHandleResponderRelease:function scrollResponderHandleResponderRelease(e){this.props.onResponderRelease&&this.props.onResponderRelease(e);var currentlyFocusedTextInput=TextInputState.currentlyFocusedField();if(this.props.keyboardShouldPersistTaps!==true&&this.props.keyboardShouldPersistTaps!=='always'&&currentlyFocusedTextInput!=null&&e.target!==currentlyFocusedTextInput&&!this.state.observedScrollSinceBecomingResponder&&!this.state.becameResponderWhileAnimating){this.props.onScrollResponderKeyboardDismissed&&this.props.onScrollResponderKeyboardDismissed(e);TextInputState.blurTextInput(currentlyFocusedTextInput);}},scrollResponderHandleScroll:function scrollResponderHandleScroll(e){this.state.observedScrollSinceBecomingResponder=true;this.props.onScroll&&this.props.onScroll(e);},scrollResponderHandleResponderGrant:function scrollResponderHandleResponderGrant(e){this.state.observedScrollSinceBecomingResponder=false;this.props.onResponderGrant&&this.props.onResponderGrant(e);this.state.becameResponderWhileAnimating=this.scrollResponderIsAnimating();},scrollResponderHandleScrollBeginDrag:function scrollResponderHandleScrollBeginDrag(e){FrameRateLogger.beginScroll();this.props.onScrollBeginDrag&&this.props.onScrollBeginDrag(e);},scrollResponderHandleScrollEndDrag:function scrollResponderHandleScrollEndDrag(e){var velocity=e.nativeEvent.velocity;if(!this.scrollResponderIsAnimating()&&(!velocity||velocity.x===0&&velocity.y===0)){FrameRateLogger.endScroll();}this.props.onScrollEndDrag&&this.props.onScrollEndDrag(e);},scrollResponderHandleMomentumScrollBegin:function scrollResponderHandleMomentumScrollBegin(e){this.state.lastMomentumScrollBeginTime=performanceNow();this.props.onMomentumScrollBegin&&this.props.onMomentumScrollBegin(e);},scrollResponderHandleMomentumScrollEnd:function scrollResponderHandleMomentumScrollEnd(e){FrameRateLogger.endScroll();this.state.lastMomentumScrollEndTime=performanceNow();this.props.onMomentumScrollEnd&&this.props.onMomentumScrollEnd(e);},scrollResponderHandleTouchStart:function scrollResponderHandleTouchStart(e){this.state.isTouching=true;this.props.onTouchStart&&this.props.onTouchStart(e);},scrollResponderHandleTouchMove:function scrollResponderHandleTouchMove(e){this.props.onTouchMove&&this.props.onTouchMove(e);},scrollResponderIsAnimating:function scrollResponderIsAnimating(){var now=performanceNow();var timeSinceLastMomentumScrollEnd=now-this.state.lastMomentumScrollEndTime;var isAnimating=timeSinceLastMomentumScrollEnd<IS_ANIMATING_TOUCH_START_THRESHOLD_MS||this.state.lastMomentumScrollEndTime<this.state.lastMomentumScrollBeginTime;return isAnimating;},scrollResponderGetScrollableNode:function scrollResponderGetScrollableNode(){return this.getScrollableNode?this.getScrollableNode():ReactNative.findNodeHandle(this);},scrollResponderScrollTo:function scrollResponderScrollTo(x,y,animated){if(typeof x==='number'){console.warn('`scrollResponderScrollTo(x, y, animated)` is deprecated. Use `scrollResponderScrollTo({x: 5, y: 5, animated: true})` instead.');}else{var _ref=x||{};x=_ref.x;y=_ref.y;animated=_ref.animated;}UIManager.dispatchViewManagerCommand(nullthrows(this.scrollResponderGetScrollableNode()),UIManager.RCTScrollView.Commands.scrollTo,[x||0,y||0,animated!==false]);},scrollResponderScrollToEnd:function scrollResponderScrollToEnd(options){var animated=(options&&options.animated)!==false;UIManager.dispatchViewManagerCommand(this.scrollResponderGetScrollableNode(),UIManager.RCTScrollView.Commands.scrollToEnd,[animated]);},scrollResponderScrollWithoutAnimationTo:function scrollResponderScrollWithoutAnimationTo(offsetX,offsetY){console.warn('`scrollResponderScrollWithoutAnimationTo` is deprecated. Use `scrollResponderScrollTo` instead');this.scrollResponderScrollTo({x:offsetX,y:offsetY,animated:false});},scrollResponderZoomTo:function scrollResponderZoomTo(rect,animated){invariant(ScrollViewManager&&ScrollViewManager.zoomToRect,'zoomToRect is not implemented');if('animated'in rect){animated=rect.animated;delete rect.animated;}else if(typeof animated!=='undefined'){console.warn('`scrollResponderZoomTo` `animated` argument is deprecated. Use `options.animated` instead');}ScrollViewManager.zoomToRect(this.scrollResponderGetScrollableNode(),rect,animated!==false);},scrollResponderFlashScrollIndicators:function scrollResponderFlashScrollIndicators(){UIManager.dispatchViewManagerCommand(this.scrollResponderGetScrollableNode(),UIManager.RCTScrollView.Commands.flashScrollIndicators,[]);},scrollResponderScrollNativeHandleToKeyboard:function scrollResponderScrollNativeHandleToKeyboard(nodeHandle,additionalOffset,preventNegativeScrollOffset){this.additionalScrollOffset=additionalOffset||0;this.preventNegativeScrollOffset=!!preventNegativeScrollOffset;UIManager.measureLayout(nodeHandle,ReactNative.findNodeHandle(this.getInnerViewNode()),this.scrollResponderTextInputFocusError,this.scrollResponderInputMeasureAndScrollToKeyboard);},scrollResponderInputMeasureAndScrollToKeyboard:function scrollResponderInputMeasureAndScrollToKeyboard(left,top,width,height){var keyboardScreenY=Dimensions.get('window').height;if(this.keyboardWillOpenTo){keyboardScreenY=this.keyboardWillOpenTo.endCoordinates.screenY;}var scrollOffsetY=top-keyboardScreenY+height+this.additionalScrollOffset;if(this.preventNegativeScrollOffset){scrollOffsetY=Math.max(0,scrollOffsetY);}this.scrollResponderScrollTo({x:0,y:scrollOffsetY,animated:true});this.additionalOffset=0;this.preventNegativeScrollOffset=false;},scrollResponderTextInputFocusError:function scrollResponderTextInputFocusError(e){console.error('Error measuring text field: ',e);},UNSAFE_componentWillMount:function UNSAFE_componentWillMount(){var keyboardShouldPersistTaps=this.props.keyboardShouldPersistTaps;warning(typeof keyboardShouldPersistTaps!=='boolean',\"'keyboardShouldPersistTaps={\"+keyboardShouldPersistTaps+\"}' is deprecated. \"+(\"Use 'keyboardShouldPersistTaps=\\\"\"+(keyboardShouldPersistTaps?'always':'never')+\"\\\"' instead\"));this.keyboardWillOpenTo=null;this.additionalScrollOffset=0;this.addListenerOn(Keyboard,'keyboardWillShow',this.scrollResponderKeyboardWillShow);this.addListenerOn(Keyboard,'keyboardWillHide',this.scrollResponderKeyboardWillHide);this.addListenerOn(Keyboard,'keyboardDidShow',this.scrollResponderKeyboardDidShow);this.addListenerOn(Keyboard,'keyboardDidHide',this.scrollResponderKeyboardDidHide);},scrollResponderKeyboardWillShow:function scrollResponderKeyboardWillShow(e){this.keyboardWillOpenTo=e;this.props.onKeyboardWillShow&&this.props.onKeyboardWillShow(e);},scrollResponderKeyboardWillHide:function scrollResponderKeyboardWillHide(e){this.keyboardWillOpenTo=null;this.props.onKeyboardWillHide&&this.props.onKeyboardWillHide(e);},scrollResponderKeyboardDidShow:function scrollResponderKeyboardDidShow(e){if(e){this.keyboardWillOpenTo=e;}this.props.onKeyboardDidShow&&this.props.onKeyboardDidShow(e);},scrollResponderKeyboardDidHide:function scrollResponderKeyboardDidHide(e){this.keyboardWillOpenTo=null;this.props.onKeyboardDidHide&&this.props.onKeyboardDidHide(e);}};var ScrollResponder={Mixin:ScrollResponderMixin};module.exports=ScrollResponder;;(function(){var reactHotLoader=require('react-hot-loader').default;var leaveModule=require('react-hot-loader').leaveModule;if(!reactHotLoader){return;}reactHotLoader.register(IS_ANIMATING_TOUCH_START_THRESHOLD_MS,\"IS_ANIMATING_TOUCH_START_THRESHOLD_MS\",\"/Users/jeffrey/HaulTesting/node_modules/react-native/Libraries/Components/ScrollResponder.js\");reactHotLoader.register(ScrollResponderMixin,\"ScrollResponderMixin\",\"/Users/jeffrey/HaulTesting/node_modules/react-native/Libraries/Components/ScrollResponder.js\");reactHotLoader.register(ScrollResponder,\"ScrollResponder\",\"/Users/jeffrey/HaulTesting/node_modules/react-native/Libraries/Components/ScrollResponder.js\");leaveModule(module);})();;",{"version":3,"sources":["/Users/jeffrey/HaulTesting/node_modules/react-native/Libraries/Components/ScrollResponder.js"],"names":["Dimensions","require","FrameRateLogger","Keyboard","ReactNative","Subscribable","TextInputState","UIManager","invariant","nullthrows","performanceNow","warning","ScrollViewManager","IS_ANIMATING_TOUCH_START_THRESHOLD_MS","ScrollResponderMixin","mixins","Mixin","scrollResponderMixinGetInitialState","isTouching","lastMomentumScrollBeginTime","lastMomentumScrollEndTime","observedScrollSinceBecomingResponder","becameResponderWhileAnimating","scrollResponderHandleScrollShouldSetResponder","state","scrollResponderHandleStartShouldSetResponder","e","currentlyFocusedTextInput","currentlyFocusedField","props","keyboardShouldPersistTaps","target","scrollResponderHandleStartShouldSetResponderCapture","scrollResponderIsAnimating","keyboardNeverPersistTaps","isTextInput","scrollResponderHandleResponderReject","scrollResponderHandleTerminationRequest","scrollResponderHandleTouchEnd","nativeEvent","touches","length","onTouchEnd","scrollResponderHandleTouchCancel","onTouchCancel","scrollResponderHandleResponderRelease","onResponderRelease","onScrollResponderKeyboardDismissed","blurTextInput","scrollResponderHandleScroll","onScroll","scrollResponderHandleResponderGrant","onResponderGrant","scrollResponderHandleScrollBeginDrag","beginScroll","onScrollBeginDrag","scrollResponderHandleScrollEndDrag","velocity","x","y","endScroll","onScrollEndDrag","scrollResponderHandleMomentumScrollBegin","onMomentumScrollBegin","scrollResponderHandleMomentumScrollEnd","onMomentumScrollEnd","scrollResponderHandleTouchStart","onTouchStart","scrollResponderHandleTouchMove","onTouchMove","now","timeSinceLastMomentumScrollEnd","isAnimating","scrollResponderGetScrollableNode","getScrollableNode","findNodeHandle","scrollResponderScrollTo","animated","console","warn","dispatchViewManagerCommand","RCTScrollView","Commands","scrollTo","scrollResponderScrollToEnd","options","scrollToEnd","scrollResponderScrollWithoutAnimationTo","offsetX","offsetY","scrollResponderZoomTo","rect","zoomToRect","scrollResponderFlashScrollIndicators","flashScrollIndicators","scrollResponderScrollNativeHandleToKeyboard","nodeHandle","additionalOffset","preventNegativeScrollOffset","additionalScrollOffset","measureLayout","getInnerViewNode","scrollResponderTextInputFocusError","scrollResponderInputMeasureAndScrollToKeyboard","left","top","width","height","keyboardScreenY","get","keyboardWillOpenTo","endCoordinates","screenY","scrollOffsetY","Math","max","error","UNSAFE_componentWillMount","addListenerOn","scrollResponderKeyboardWillShow","scrollResponderKeyboardWillHide","scrollResponderKeyboardDidShow","scrollResponderKeyboardDidHide","onKeyboardWillShow","onKeyboardWillHide","onKeyboardDidShow","onKeyboardDidHide","ScrollResponder","module","exports"],"mappings":"AAUA,a,0GAEA,GAAMA,CAAAA,UAAU,CAAGC,OAAO,CAAC,YAAD,CAA1B,CACA,GAAMC,CAAAA,eAAe,CAAGD,OAAO,CAAC,iBAAD,CAA/B,CACA,GAAME,CAAAA,QAAQ,CAAGF,OAAO,CAAC,UAAD,CAAxB,CACA,GAAMG,CAAAA,WAAW,CAAGH,OAAO,CAAC,aAAD,CAA3B,CACA,GAAMI,CAAAA,YAAY,CAAGJ,OAAO,CAAC,cAAD,CAA5B,CACA,GAAMK,CAAAA,cAAc,CAAGL,OAAO,CAAC,gBAAD,CAA9B,CACA,GAAMM,CAAAA,SAAS,CAAGN,OAAO,CAAC,WAAD,CAAzB,CAEA,GAAMO,CAAAA,SAAS,CAAGP,OAAO,CAAC,oBAAD,CAAzB,CACA,GAAMQ,CAAAA,UAAU,CAAGR,OAAO,CAAC,qBAAD,CAA1B,CACA,GAAMS,CAAAA,cAAc,CAAGT,OAAO,CAAC,yBAAD,CAA9B,CACA,GAAMU,CAAAA,OAAO,CAAGV,OAAO,CAAC,kBAAD,CAAvB,C,aAE4BA,OAAO,CAAC,eAAD,C,CAA5BW,iB,UAAAA,iB,CAgFP,GAAMC,CAAAA,qCAAqC,CAAG,EAA9C,CAWA,GAAMC,CAAAA,oBAAoB,CAAG,CAC3BC,MAAM,CAAE,CAACV,YAAY,CAACW,KAAd,CADmB,CAE3BC,mCAAmC,CAAE,8CAAkB,CACrD,MAAO,CACLC,UAAU,CAAE,KADP,CAELC,2BAA2B,CAAE,CAFxB,CAGLC,yBAAyB,CAAE,CAHtB,CAULC,oCAAoC,CAAE,KAVjC,CAWLC,6BAA6B,CAAE,KAX1B,CAAP,CAaD,CAhB0B,CAqB3BC,6CAA6C,CAAE,wDAAoB,CACjE,MAAO,MAAKC,KAAL,CAAWN,UAAlB,CACD,CAvB0B,CAkD3BO,4CAA4C,CAAE,sDAASC,CAAT,CAA4B,CACxE,GAAMC,CAAAA,yBAAyB,CAAGrB,cAAc,CAACsB,qBAAf,EAAlC,CAEA,GACE,KAAKC,KAAL,CAAWC,yBAAX,GAAyC,SAAzC,EACAH,yBAAyB,EAAI,IAD7B,EAEAD,CAAC,CAACK,MAAF,GAAaJ,yBAHf,CAIE,CACA,MAAO,KAAP,CACD,CACD,MAAO,MAAP,CACD,CA7D0B,CA0E3BK,mDAAmD,CAAE,6DACnDN,CADmD,CAE1C,CAGT,GAAI,KAAKO,0BAAL,EAAJ,CAAuC,CACrC,MAAO,KAAP,CACD,CAMD,GAAMN,CAAAA,yBAAyB,CAAGrB,cAAc,CAACsB,qBAAf,EAAlC,CAXS,GAYFE,CAAAA,yBAZE,CAY2B,KAAKD,KAZhC,CAYFC,yBAZE,CAaT,GAAMI,CAAAA,wBAAwB,CAC5B,CAACJ,yBAAD,EAA8BA,yBAAyB,GAAK,OAD9D,CAEA,GACEI,wBAAwB,EACxBP,yBAAyB,EAAI,IAD7B,EAEA,CAACrB,cAAc,CAAC6B,WAAf,CAA2BT,CAAC,CAACK,MAA7B,CAHH,CAIE,CACA,MAAO,KAAP,CACD,CAED,MAAO,MAAP,CACD,CApG0B,CAgH3BK,oCAAoC,CAAE,+CAAW,CAAE,CAhHxB,CAiI3BC,uCAAuC,CAAE,kDAAoB,CAC3D,MAAO,CAAC,KAAKb,KAAL,CAAWH,oCAAnB,CACD,CAnI0B,CA0I3BiB,6BAA6B,CAAE,uCAASZ,CAAT,CAAmB,CAChD,GAAMa,CAAAA,WAAW,CAAGb,CAAC,CAACa,WAAtB,CACA,KAAKf,KAAL,CAAWN,UAAX,CAAwBqB,WAAW,CAACC,OAAZ,CAAoBC,MAApB,GAA+B,CAAvD,CACA,KAAKZ,KAAL,CAAWa,UAAX,EAAyB,KAAKb,KAAL,CAAWa,UAAX,CAAsBhB,CAAtB,CAAzB,CACD,CA9I0B,CAqJ3BiB,gCAAgC,CAAE,0CAASjB,CAAT,CAAmB,CACnD,KAAKF,KAAL,CAAWN,UAAX,CAAwB,KAAxB,CACA,KAAKW,KAAL,CAAWe,aAAX,EAA4B,KAAKf,KAAL,CAAWe,aAAX,CAAyBlB,CAAzB,CAA5B,CACD,CAxJ0B,CA6J3BmB,qCAAqC,CAAE,+CAASnB,CAAT,CAAmB,CACxD,KAAKG,KAAL,CAAWiB,kBAAX,EAAiC,KAAKjB,KAAL,CAAWiB,kBAAX,CAA8BpB,CAA9B,CAAjC,CAIA,GAAMC,CAAAA,yBAAyB,CAAGrB,cAAc,CAACsB,qBAAf,EAAlC,CACA,GACE,KAAKC,KAAL,CAAWC,yBAAX,GAAyC,IAAzC,EACA,KAAKD,KAAL,CAAWC,yBAAX,GAAyC,QADzC,EAEAH,yBAAyB,EAAI,IAF7B,EAGAD,CAAC,CAACK,MAAF,GAAaJ,yBAHb,EAIA,CAAC,KAAKH,KAAL,CAAWH,oCAJZ,EAKA,CAAC,KAAKG,KAAL,CAAWF,6BANd,CAOE,CACA,KAAKO,KAAL,CAAWkB,kCAAX,EACE,KAAKlB,KAAL,CAAWkB,kCAAX,CAA8CrB,CAA9C,CADF,CAEApB,cAAc,CAAC0C,aAAf,CAA6BrB,yBAA7B,EACD,CACF,CA/K0B,CAiL3BsB,2BAA2B,CAAE,qCAASvB,CAAT,CAAmB,CAC9C,KAAKF,KAAL,CAAWH,oCAAX,CAAkD,IAAlD,CACA,KAAKQ,KAAL,CAAWqB,QAAX,EAAuB,KAAKrB,KAAL,CAAWqB,QAAX,CAAoBxB,CAApB,CAAvB,CACD,CApL0B,CAyL3ByB,mCAAmC,CAAE,6CAASzB,CAAT,CAAmB,CACtD,KAAKF,KAAL,CAAWH,oCAAX,CAAkD,KAAlD,CACA,KAAKQ,KAAL,CAAWuB,gBAAX,EAA+B,KAAKvB,KAAL,CAAWuB,gBAAX,CAA4B1B,CAA5B,CAA/B,CACA,KAAKF,KAAL,CAAWF,6BAAX,CAA2C,KAAKW,0BAAL,EAA3C,CACD,CA7L0B,CAsM3BoB,oCAAoC,CAAE,8CAAS3B,CAAT,CAAmB,CACvDxB,eAAe,CAACoD,WAAhB,GACA,KAAKzB,KAAL,CAAW0B,iBAAX,EAAgC,KAAK1B,KAAL,CAAW0B,iBAAX,CAA6B7B,CAA7B,CAAhC,CACD,CAzM0B,CA8M3B8B,kCAAkC,CAAE,4CAAS9B,CAAT,CAAmB,IAC9C+B,CAAAA,QAD8C,CAClC/B,CAAC,CAACa,WADgC,CAC9CkB,QAD8C,CAOrD,GACE,CAAC,KAAKxB,0BAAL,EAAD,GACC,CAACwB,QAAD,EAAcA,QAAQ,CAACC,CAAT,GAAe,CAAf,EAAoBD,QAAQ,CAACE,CAAT,GAAe,CADlD,CADF,CAGE,CACAzD,eAAe,CAAC0D,SAAhB,GACD,CACD,KAAK/B,KAAL,CAAWgC,eAAX,EAA8B,KAAKhC,KAAL,CAAWgC,eAAX,CAA2BnC,CAA3B,CAA9B,CACD,CA5N0B,CAiO3BoC,wCAAwC,CAAE,kDAASpC,CAAT,CAAmB,CAC3D,KAAKF,KAAL,CAAWL,2BAAX,CAAyCT,cAAc,EAAvD,CACA,KAAKmB,KAAL,CAAWkC,qBAAX,EAAoC,KAAKlC,KAAL,CAAWkC,qBAAX,CAAiCrC,CAAjC,CAApC,CACD,CApO0B,CAyO3BsC,sCAAsC,CAAE,gDAAStC,CAAT,CAAmB,CACzDxB,eAAe,CAAC0D,SAAhB,GACA,KAAKpC,KAAL,CAAWJ,yBAAX,CAAuCV,cAAc,EAArD,CACA,KAAKmB,KAAL,CAAWoC,mBAAX,EAAkC,KAAKpC,KAAL,CAAWoC,mBAAX,CAA+BvC,CAA/B,CAAlC,CACD,CA7O0B,CA0P3BwC,+BAA+B,CAAE,yCAASxC,CAAT,CAAmB,CAClD,KAAKF,KAAL,CAAWN,UAAX,CAAwB,IAAxB,CACA,KAAKW,KAAL,CAAWsC,YAAX,EAA2B,KAAKtC,KAAL,CAAWsC,YAAX,CAAwBzC,CAAxB,CAA3B,CACD,CA7P0B,CA0Q3B0C,8BAA8B,CAAE,wCAAS1C,CAAT,CAAmB,CACjD,KAAKG,KAAL,CAAWwC,WAAX,EAA0B,KAAKxC,KAAL,CAAWwC,WAAX,CAAuB3C,CAAvB,CAA1B,CACD,CA5Q0B,CAmR3BO,0BAA0B,CAAE,qCAAoB,CAC9C,GAAMqC,CAAAA,GAAG,CAAG5D,cAAc,EAA1B,CACA,GAAM6D,CAAAA,8BAA8B,CAClCD,GAAG,CAAG,KAAK9C,KAAL,CAAWJ,yBADnB,CAEA,GAAMoD,CAAAA,WAAW,CACfD,8BAA8B,CAAG1D,qCAAjC,EACA,KAAKW,KAAL,CAAWJ,yBAAX,CACE,KAAKI,KAAL,CAAWL,2BAHf,CAIA,MAAOqD,CAAAA,WAAP,CACD,CA5R0B,CAmS3BC,gCAAgC,CAAE,2CAAgB,CAChD,MAAO,MAAKC,iBAAL,CACH,KAAKA,iBAAL,EADG,CAEHtE,WAAW,CAACuE,cAAZ,CAA2B,IAA3B,CAFJ,CAGD,CAvS0B,CAoT3BC,uBAAuB,CAAE,iCACvBlB,CADuB,CAEvBC,CAFuB,CAGvBkB,QAHuB,CAIvB,CACA,GAAI,MAAOnB,CAAAA,CAAP,GAAa,QAAjB,CAA2B,CACzBoB,OAAO,CAACC,IAAR,CACE,+HADF,EAGD,CAJD,IAIO,UACerB,CAAC,EAAI,EADpB,CACHA,CADG,MACHA,CADG,CACAC,CADA,MACAA,CADA,CACGkB,QADH,MACGA,QADH,CAEN,CACDtE,SAAS,CAACyE,0BAAV,CACEvE,UAAU,CAAC,KAAKgE,gCAAL,EAAD,CADZ,CAEElE,SAAS,CAAC0E,aAAV,CAAwBC,QAAxB,CAAiCC,QAFnC,CAGE,CAACzB,CAAC,EAAI,CAAN,CAASC,CAAC,EAAI,CAAd,CAAiBkB,QAAQ,GAAK,KAA9B,CAHF,EAKD,CArU0B,CA+U3BO,0BAA0B,CAAE,oCAASC,OAAT,CAAyC,CAEnE,GAAMR,CAAAA,QAAQ,CAAG,CAACQ,OAAO,EAAIA,OAAO,CAACR,QAApB,IAAkC,KAAnD,CACAtE,SAAS,CAACyE,0BAAV,CACE,KAAKP,gCAAL,EADF,CAEElE,SAAS,CAAC0E,aAAV,CAAwBC,QAAxB,CAAiCI,WAFnC,CAGE,CAACT,QAAD,CAHF,EAKD,CAvV0B,CA4V3BU,uCAAuC,CAAE,iDACvCC,OADuC,CAEvCC,OAFuC,CAGvC,CACAX,OAAO,CAACC,IAAR,CACE,gGADF,EAGA,KAAKH,uBAAL,CAA6B,CAAClB,CAAC,CAAE8B,OAAJ,CAAa7B,CAAC,CAAE8B,OAAhB,CAAyBZ,QAAQ,CAAE,KAAnC,CAA7B,EACD,CApW0B,CA4W3Ba,qBAAqB,CAAE,+BACrBC,IADqB,CAQrBd,QARqB,CASrB,CACArE,SAAS,CACPI,iBAAiB,EAAIA,iBAAiB,CAACgF,UADhC,CAEP,+BAFO,CAAT,CAIA,GAAI,YAAcD,CAAAA,IAAlB,CAAwB,CACtBd,QAAQ,CAAGc,IAAI,CAACd,QAAhB,CACA,MAAOc,CAAAA,IAAI,CAACd,QAAZ,CACD,CAHD,IAGO,IAAI,MAAOA,CAAAA,QAAP,GAAoB,WAAxB,CAAqC,CAC1CC,OAAO,CAACC,IAAR,CACE,2FADF,EAGD,CACDnE,iBAAiB,CAACgF,UAAlB,CACE,KAAKnB,gCAAL,EADF,CAEEkB,IAFF,CAGEd,QAAQ,GAAK,KAHf,EAKD,CAvY0B,CA4Y3BgB,oCAAoC,CAAE,+CAAW,CAC/CtF,SAAS,CAACyE,0BAAV,CACE,KAAKP,gCAAL,EADF,CAEElE,SAAS,CAAC0E,aAAV,CAAwBC,QAAxB,CAAiCY,qBAFnC,CAGE,EAHF,EAKD,CAlZ0B,CA8Z3BC,2CAA2C,CAAE,qDAC3CC,UAD2C,CAE3CC,gBAF2C,CAG3CC,2BAH2C,CAI3C,CACA,KAAKC,sBAAL,CAA8BF,gBAAgB,EAAI,CAAlD,CACA,KAAKC,2BAAL,CAAmC,CAAC,CAACA,2BAArC,CACA3F,SAAS,CAAC6F,aAAV,CACEJ,UADF,CAEE5F,WAAW,CAACuE,cAAZ,CAA2B,KAAK0B,gBAAL,EAA3B,CAFF,CAGE,KAAKC,kCAHP,CAIE,KAAKC,8CAJP,EAMD,CA3a0B,CAub3BA,8CAA8C,CAAE,wDAC9CC,IAD8C,CAE9CC,GAF8C,CAG9CC,KAH8C,CAI9CC,MAJ8C,CAK9C,CACA,GAAIC,CAAAA,eAAe,CAAG5G,UAAU,CAAC6G,GAAX,CAAe,QAAf,EAAyBF,MAA/C,CACA,GAAI,KAAKG,kBAAT,CAA6B,CAC3BF,eAAe,CAAG,KAAKE,kBAAL,CAAwBC,cAAxB,CAAuCC,OAAzD,CACD,CACD,GAAIC,CAAAA,aAAa,CACfR,GAAG,CAAGG,eAAN,CAAwBD,MAAxB,CAAiC,KAAKR,sBADxC,CAOA,GAAI,KAAKD,2BAAT,CAAsC,CACpCe,aAAa,CAAGC,IAAI,CAACC,GAAL,CAAS,CAAT,CAAYF,aAAZ,CAAhB,CACD,CACD,KAAKrC,uBAAL,CAA6B,CAAClB,CAAC,CAAE,CAAJ,CAAOC,CAAC,CAAEsD,aAAV,CAAyBpC,QAAQ,CAAE,IAAnC,CAA7B,EAEA,KAAKoB,gBAAL,CAAwB,CAAxB,CACA,KAAKC,2BAAL,CAAmC,KAAnC,CACD,CA/c0B,CAid3BI,kCAAkC,CAAE,4CAAS5E,CAAT,CAAmB,CACrDoD,OAAO,CAACsC,KAAR,CAAc,8BAAd,CAA8C1F,CAA9C,EACD,CAnd0B,CA2d3B2F,yBAAyB,CAAE,oCAAW,IAC7BvF,CAAAA,yBAD6B,CACA,KAAKD,KADL,CAC7BC,yBAD6B,CAEpCnB,OAAO,CACL,MAAOmB,CAAAA,yBAAP,GAAqC,SADhC,CAEL,+BAA+BA,yBAA/B,4DAEIA,yBAAyB,CAAG,QAAH,CAAc,OAF3C,gBAFK,CAAP,CAQA,KAAKgF,kBAAL,CAA0B,IAA1B,CACA,KAAKX,sBAAL,CAA8B,CAA9B,CACA,KAAKmB,aAAL,CACEnH,QADF,CAEE,kBAFF,CAGE,KAAKoH,+BAHP,EAKA,KAAKD,aAAL,CACEnH,QADF,CAEE,kBAFF,CAGE,KAAKqH,+BAHP,EAKA,KAAKF,aAAL,CACEnH,QADF,CAEE,iBAFF,CAGE,KAAKsH,8BAHP,EAKA,KAAKH,aAAL,CACEnH,QADF,CAEE,iBAFF,CAGE,KAAKuH,8BAHP,EAKD,CA3f0B,CAyhB3BH,+BAA+B,CAAE,yCAAS7F,CAAT,CAAmB,CAClD,KAAKoF,kBAAL,CAA0BpF,CAA1B,CACA,KAAKG,KAAL,CAAW8F,kBAAX,EAAiC,KAAK9F,KAAL,CAAW8F,kBAAX,CAA8BjG,CAA9B,CAAjC,CACD,CA5hB0B,CA8hB3B8F,+BAA+B,CAAE,yCAAS9F,CAAT,CAAmB,CAClD,KAAKoF,kBAAL,CAA0B,IAA1B,CACA,KAAKjF,KAAL,CAAW+F,kBAAX,EAAiC,KAAK/F,KAAL,CAAW+F,kBAAX,CAA8BlG,CAA9B,CAAjC,CACD,CAjiB0B,CAmiB3B+F,8BAA8B,CAAE,wCAAS/F,CAAT,CAAmB,CAGjD,GAAIA,CAAJ,CAAO,CACL,KAAKoF,kBAAL,CAA0BpF,CAA1B,CACD,CACD,KAAKG,KAAL,CAAWgG,iBAAX,EAAgC,KAAKhG,KAAL,CAAWgG,iBAAX,CAA6BnG,CAA7B,CAAhC,CACD,CA1iB0B,CA4iB3BgG,8BAA8B,CAAE,wCAAShG,CAAT,CAAmB,CACjD,KAAKoF,kBAAL,CAA0B,IAA1B,CACA,KAAKjF,KAAL,CAAWiG,iBAAX,EAAgC,KAAKjG,KAAL,CAAWiG,iBAAX,CAA6BpG,CAA7B,CAAhC,CACD,CA/iB0B,CAA7B,CAkjBA,GAAMqG,CAAAA,eAAe,CAAG,CACtB/G,KAAK,CAAEF,oBADe,CAAxB,CAIAkH,MAAM,CAACC,OAAP,CAAiBF,eAAjB,C,gLAjkBMlH,qC,iKAWAC,oB,gJAkjBAiH,e","sourcesContent":["/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @format\n * @flow\n */\n\n'use strict';\n\nconst Dimensions = require('Dimensions');\nconst FrameRateLogger = require('FrameRateLogger');\nconst Keyboard = require('Keyboard');\nconst ReactNative = require('ReactNative');\nconst Subscribable = require('Subscribable');\nconst TextInputState = require('TextInputState');\nconst UIManager = require('UIManager');\n\nconst invariant = require('fbjs/lib/invariant');\nconst nullthrows = require('fbjs/lib/nullthrows');\nconst performanceNow = require('fbjs/lib/performanceNow');\nconst warning = require('fbjs/lib/warning');\n\nconst {ScrollViewManager} = require('NativeModules');\n\n/**\n * Mixin that can be integrated in order to handle scrolling that plays well\n * with `ResponderEventPlugin`. Integrate with your platform specific scroll\n * views, or even your custom built (every-frame animating) scroll views so that\n * all of these systems play well with the `ResponderEventPlugin`.\n *\n * iOS scroll event timing nuances:\n * ===============================\n *\n *\n * Scrolling without bouncing, if you touch down:\n * -------------------------------\n *\n * 1. `onMomentumScrollBegin` (when animation begins after letting up)\n *    ... physical touch starts ...\n * 2. `onTouchStartCapture`   (when you press down to stop the scroll)\n * 3. `onTouchStart`          (same, but bubble phase)\n * 4. `onResponderRelease`    (when lifting up - you could pause forever before * lifting)\n * 5. `onMomentumScrollEnd`\n *\n *\n * Scrolling with bouncing, if you touch down:\n * -------------------------------\n *\n * 1. `onMomentumScrollBegin` (when animation begins after letting up)\n *    ... bounce begins ...\n *    ... some time elapses ...\n *    ... physical touch during bounce ...\n * 2. `onMomentumScrollEnd`   (Makes no sense why this occurs first during bounce)\n * 3. `onTouchStartCapture`   (immediately after `onMomentumScrollEnd`)\n * 4. `onTouchStart`          (same, but bubble phase)\n * 5. `onTouchEnd`            (You could hold the touch start for a long time)\n * 6. `onMomentumScrollBegin` (When releasing the view starts bouncing back)\n *\n * So when we receive an `onTouchStart`, how can we tell if we are touching\n * *during* an animation (which then causes the animation to stop)? The only way\n * to tell is if the `touchStart` occurred immediately after the\n * `onMomentumScrollEnd`.\n *\n * This is abstracted out for you, so you can just call this.scrollResponderIsAnimating() if\n * necessary\n *\n * `ScrollResponder` also includes logic for blurring a currently focused input\n * if one is focused while scrolling. The `ScrollResponder` is a natural place\n * to put this logic since it can support not dismissing the keyboard while\n * scrolling, unless a recognized \"tap\"-like gesture has occurred.\n *\n * The public lifecycle API includes events for keyboard interaction, responder\n * interaction, and scrolling (among others). The keyboard callbacks\n * `onKeyboardWill/Did/*` are *global* events, but are invoked on scroll\n * responder's props so that you can guarantee that the scroll responder's\n * internal state has been updated accordingly (and deterministically) by\n * the time the props callbacks are invoke. Otherwise, you would always wonder\n * if the scroll responder is currently in a state where it recognizes new\n * keyboard positions etc. If coordinating scrolling with keyboard movement,\n * *always* use these hooks instead of listening to your own global keyboard\n * events.\n *\n * Public keyboard lifecycle API: (props callbacks)\n *\n * Standard Keyboard Appearance Sequence:\n *\n *   this.props.onKeyboardWillShow\n *   this.props.onKeyboardDidShow\n *\n * `onScrollResponderKeyboardDismissed` will be invoked if an appropriate\n * tap inside the scroll responder's scrollable region was responsible\n * for the dismissal of the keyboard. There are other reasons why the\n * keyboard could be dismissed.\n *\n *   this.props.onScrollResponderKeyboardDismissed\n *\n * Standard Keyboard Hide Sequence:\n *\n *   this.props.onKeyboardWillHide\n *   this.props.onKeyboardDidHide\n */\n\nconst IS_ANIMATING_TOUCH_START_THRESHOLD_MS = 16;\n\ntype State = {\n  isTouching: boolean,\n  lastMomentumScrollBeginTime: number,\n  lastMomentumScrollEndTime: number,\n  observedScrollSinceBecomingResponder: boolean,\n  becameResponderWhileAnimating: boolean,\n};\ntype Event = Object;\n\nconst ScrollResponderMixin = {\n  mixins: [Subscribable.Mixin],\n  scrollResponderMixinGetInitialState: function(): State {\n    return {\n      isTouching: false,\n      lastMomentumScrollBeginTime: 0,\n      lastMomentumScrollEndTime: 0,\n\n      // Reset to false every time becomes responder. This is used to:\n      // - Determine if the scroll view has been scrolled and therefore should\n      // refuse to give up its responder lock.\n      // - Determine if releasing should dismiss the keyboard when we are in\n      // tap-to-dismiss mode (this.props.keyboardShouldPersistTaps !== 'always').\n      observedScrollSinceBecomingResponder: false,\n      becameResponderWhileAnimating: false,\n    };\n  },\n\n  /**\n   * Invoke this from an `onScroll` event.\n   */\n  scrollResponderHandleScrollShouldSetResponder: function(): boolean {\n    return this.state.isTouching;\n  },\n\n  /**\n   * Merely touch starting is not sufficient for a scroll view to become the\n   * responder. Being the \"responder\" means that the very next touch move/end\n   * event will result in an action/movement.\n   *\n   * Invoke this from an `onStartShouldSetResponder` event.\n   *\n   * `onStartShouldSetResponder` is used when the next move/end will trigger\n   * some UI movement/action, but when you want to yield priority to views\n   * nested inside of the view.\n   *\n   * There may be some cases where scroll views actually should return `true`\n   * from `onStartShouldSetResponder`: Any time we are detecting a standard tap\n   * that gives priority to nested views.\n   *\n   * - If a single tap on the scroll view triggers an action such as\n   *   recentering a map style view yet wants to give priority to interaction\n   *   views inside (such as dropped pins or labels), then we would return true\n   *   from this method when there is a single touch.\n   *\n   * - Similar to the previous case, if a two finger \"tap\" should trigger a\n   *   zoom, we would check the `touches` count, and if `>= 2`, we would return\n   *   true.\n   *\n   */\n  scrollResponderHandleStartShouldSetResponder: function(e: Event): boolean {\n    const currentlyFocusedTextInput = TextInputState.currentlyFocusedField();\n\n    if (\n      this.props.keyboardShouldPersistTaps === 'handled' &&\n      currentlyFocusedTextInput != null &&\n      e.target !== currentlyFocusedTextInput\n    ) {\n      return true;\n    }\n    return false;\n  },\n\n  /**\n   * There are times when the scroll view wants to become the responder\n   * (meaning respond to the next immediate `touchStart/touchEnd`), in a way\n   * that *doesn't* give priority to nested views (hence the capture phase):\n   *\n   * - Currently animating.\n   * - Tapping anywhere that is not a text input, while the keyboard is\n   *   up (which should dismiss the keyboard).\n   *\n   * Invoke this from an `onStartShouldSetResponderCapture` event.\n   */\n  scrollResponderHandleStartShouldSetResponderCapture: function(\n    e: Event,\n  ): boolean {\n    // The scroll view should receive taps instead of its descendants if:\n    // * it is already animating/decelerating\n    if (this.scrollResponderIsAnimating()) {\n      return true;\n    }\n\n    // * the keyboard is up, keyboardShouldPersistTaps is 'never' (the default),\n    // and a new touch starts with a non-textinput target (in which case the\n    // first tap should be sent to the scroll view and dismiss the keyboard,\n    // then the second tap goes to the actual interior view)\n    const currentlyFocusedTextInput = TextInputState.currentlyFocusedField();\n    const {keyboardShouldPersistTaps} = this.props;\n    const keyboardNeverPersistTaps =\n      !keyboardShouldPersistTaps || keyboardShouldPersistTaps === 'never';\n    if (\n      keyboardNeverPersistTaps &&\n      currentlyFocusedTextInput != null &&\n      !TextInputState.isTextInput(e.target)\n    ) {\n      return true;\n    }\n\n    return false;\n  },\n\n  /**\n   * Invoke this from an `onResponderReject` event.\n   *\n   * Some other element is not yielding its role as responder. Normally, we'd\n   * just disable the `UIScrollView`, but a touch has already began on it, the\n   * `UIScrollView` will not accept being disabled after that. The easiest\n   * solution for now is to accept the limitation of disallowing this\n   * altogether. To improve this, find a way to disable the `UIScrollView` after\n   * a touch has already started.\n   */\n  scrollResponderHandleResponderReject: function() {},\n\n  /**\n   * We will allow the scroll view to give up its lock iff it acquired the lock\n   * during an animation. This is a very useful default that happens to satisfy\n   * many common user experiences.\n   *\n   * - Stop a scroll on the left edge, then turn that into an outer view's\n   *   backswipe.\n   * - Stop a scroll mid-bounce at the top, continue pulling to have the outer\n   *   view dismiss.\n   * - However, without catching the scroll view mid-bounce (while it is\n   *   motionless), if you drag far enough for the scroll view to become\n   *   responder (and therefore drag the scroll view a bit), any backswipe\n   *   navigation of a swipe gesture higher in the view hierarchy, should be\n   *   rejected.\n   */\n  scrollResponderHandleTerminationRequest: function(): boolean {\n    return !this.state.observedScrollSinceBecomingResponder;\n  },\n\n  /**\n   * Invoke this from an `onTouchEnd` event.\n   *\n   * @param {SyntheticEvent} e Event.\n   */\n  scrollResponderHandleTouchEnd: function(e: Event) {\n    const nativeEvent = e.nativeEvent;\n    this.state.isTouching = nativeEvent.touches.length !== 0;\n    this.props.onTouchEnd && this.props.onTouchEnd(e);\n  },\n\n  /**\n   * Invoke this from an `onTouchCancel` event.\n   *\n   * @param {SyntheticEvent} e Event.\n   */\n  scrollResponderHandleTouchCancel: function(e: Event) {\n    this.state.isTouching = false;\n    this.props.onTouchCancel && this.props.onTouchCancel(e);\n  },\n\n  /**\n   * Invoke this from an `onResponderRelease` event.\n   */\n  scrollResponderHandleResponderRelease: function(e: Event) {\n    this.props.onResponderRelease && this.props.onResponderRelease(e);\n\n    // By default scroll views will unfocus a textField\n    // if another touch occurs outside of it\n    const currentlyFocusedTextInput = TextInputState.currentlyFocusedField();\n    if (\n      this.props.keyboardShouldPersistTaps !== true &&\n      this.props.keyboardShouldPersistTaps !== 'always' &&\n      currentlyFocusedTextInput != null &&\n      e.target !== currentlyFocusedTextInput &&\n      !this.state.observedScrollSinceBecomingResponder &&\n      !this.state.becameResponderWhileAnimating\n    ) {\n      this.props.onScrollResponderKeyboardDismissed &&\n        this.props.onScrollResponderKeyboardDismissed(e);\n      TextInputState.blurTextInput(currentlyFocusedTextInput);\n    }\n  },\n\n  scrollResponderHandleScroll: function(e: Event) {\n    this.state.observedScrollSinceBecomingResponder = true;\n    this.props.onScroll && this.props.onScroll(e);\n  },\n\n  /**\n   * Invoke this from an `onResponderGrant` event.\n   */\n  scrollResponderHandleResponderGrant: function(e: Event) {\n    this.state.observedScrollSinceBecomingResponder = false;\n    this.props.onResponderGrant && this.props.onResponderGrant(e);\n    this.state.becameResponderWhileAnimating = this.scrollResponderIsAnimating();\n  },\n\n  /**\n   * Unfortunately, `onScrollBeginDrag` also fires when *stopping* the scroll\n   * animation, and there's not an easy way to distinguish a drag vs. stopping\n   * momentum.\n   *\n   * Invoke this from an `onScrollBeginDrag` event.\n   */\n  scrollResponderHandleScrollBeginDrag: function(e: Event) {\n    FrameRateLogger.beginScroll(); // TODO: track all scrolls after implementing onScrollEndAnimation\n    this.props.onScrollBeginDrag && this.props.onScrollBeginDrag(e);\n  },\n\n  /**\n   * Invoke this from an `onScrollEndDrag` event.\n   */\n  scrollResponderHandleScrollEndDrag: function(e: Event) {\n    const {velocity} = e.nativeEvent;\n    // - If we are animating, then this is a \"drag\" that is stopping the scrollview and momentum end\n    //   will fire.\n    // - If velocity is non-zero, then the interaction will stop when momentum scroll ends or\n    //   another drag starts and ends.\n    // - If we don't get velocity, better to stop the interaction twice than not stop it.\n    if (\n      !this.scrollResponderIsAnimating() &&\n      (!velocity || (velocity.x === 0 && velocity.y === 0))\n    ) {\n      FrameRateLogger.endScroll();\n    }\n    this.props.onScrollEndDrag && this.props.onScrollEndDrag(e);\n  },\n\n  /**\n   * Invoke this from an `onMomentumScrollBegin` event.\n   */\n  scrollResponderHandleMomentumScrollBegin: function(e: Event) {\n    this.state.lastMomentumScrollBeginTime = performanceNow();\n    this.props.onMomentumScrollBegin && this.props.onMomentumScrollBegin(e);\n  },\n\n  /**\n   * Invoke this from an `onMomentumScrollEnd` event.\n   */\n  scrollResponderHandleMomentumScrollEnd: function(e: Event) {\n    FrameRateLogger.endScroll();\n    this.state.lastMomentumScrollEndTime = performanceNow();\n    this.props.onMomentumScrollEnd && this.props.onMomentumScrollEnd(e);\n  },\n\n  /**\n   * Invoke this from an `onTouchStart` event.\n   *\n   * Since we know that the `SimpleEventPlugin` occurs later in the plugin\n   * order, after `ResponderEventPlugin`, we can detect that we were *not*\n   * permitted to be the responder (presumably because a contained view became\n   * responder). The `onResponderReject` won't fire in that case - it only\n   * fires when a *current* responder rejects our request.\n   *\n   * @param {SyntheticEvent} e Touch Start event.\n   */\n  scrollResponderHandleTouchStart: function(e: Event) {\n    this.state.isTouching = true;\n    this.props.onTouchStart && this.props.onTouchStart(e);\n  },\n\n  /**\n   * Invoke this from an `onTouchMove` event.\n   *\n   * Since we know that the `SimpleEventPlugin` occurs later in the plugin\n   * order, after `ResponderEventPlugin`, we can detect that we were *not*\n   * permitted to be the responder (presumably because a contained view became\n   * responder). The `onResponderReject` won't fire in that case - it only\n   * fires when a *current* responder rejects our request.\n   *\n   * @param {SyntheticEvent} e Touch Start event.\n   */\n  scrollResponderHandleTouchMove: function(e: Event) {\n    this.props.onTouchMove && this.props.onTouchMove(e);\n  },\n\n  /**\n   * A helper function for this class that lets us quickly determine if the\n   * view is currently animating. This is particularly useful to know when\n   * a touch has just started or ended.\n   */\n  scrollResponderIsAnimating: function(): boolean {\n    const now = performanceNow();\n    const timeSinceLastMomentumScrollEnd =\n      now - this.state.lastMomentumScrollEndTime;\n    const isAnimating =\n      timeSinceLastMomentumScrollEnd < IS_ANIMATING_TOUCH_START_THRESHOLD_MS ||\n      this.state.lastMomentumScrollEndTime <\n        this.state.lastMomentumScrollBeginTime;\n    return isAnimating;\n  },\n\n  /**\n   * Returns the node that represents native view that can be scrolled.\n   * Components can pass what node to use by defining a `getScrollableNode`\n   * function otherwise `this` is used.\n   */\n  scrollResponderGetScrollableNode: function(): any {\n    return this.getScrollableNode\n      ? this.getScrollableNode()\n      : ReactNative.findNodeHandle(this);\n  },\n\n  /**\n   * A helper function to scroll to a specific point in the ScrollView.\n   * This is currently used to help focus child TextViews, but can also\n   * be used to quickly scroll to any element we want to focus. Syntax:\n   *\n   * `scrollResponderScrollTo(options: {x: number = 0; y: number = 0; animated: boolean = true})`\n   *\n   * Note: The weird argument signature is due to the fact that, for historical reasons,\n   * the function also accepts separate arguments as as alternative to the options object.\n   * This is deprecated due to ambiguity (y before x), and SHOULD NOT BE USED.\n   */\n  scrollResponderScrollTo: function(\n    x?: number | {x?: number, y?: number, animated?: boolean},\n    y?: number,\n    animated?: boolean,\n  ) {\n    if (typeof x === 'number') {\n      console.warn(\n        '`scrollResponderScrollTo(x, y, animated)` is deprecated. Use `scrollResponderScrollTo({x: 5, y: 5, animated: true})` instead.',\n      );\n    } else {\n      ({x, y, animated} = x || {});\n    }\n    UIManager.dispatchViewManagerCommand(\n      nullthrows(this.scrollResponderGetScrollableNode()),\n      UIManager.RCTScrollView.Commands.scrollTo,\n      [x || 0, y || 0, animated !== false],\n    );\n  },\n\n  /**\n   * Scrolls to the end of the ScrollView, either immediately or with a smooth\n   * animation.\n   *\n   * Example:\n   *\n   * `scrollResponderScrollToEnd({animated: true})`\n   */\n  scrollResponderScrollToEnd: function(options?: {animated?: boolean}) {\n    // Default to true\n    const animated = (options && options.animated) !== false;\n    UIManager.dispatchViewManagerCommand(\n      this.scrollResponderGetScrollableNode(),\n      UIManager.RCTScrollView.Commands.scrollToEnd,\n      [animated],\n    );\n  },\n\n  /**\n   * Deprecated, do not use.\n   */\n  scrollResponderScrollWithoutAnimationTo: function(\n    offsetX: number,\n    offsetY: number,\n  ) {\n    console.warn(\n      '`scrollResponderScrollWithoutAnimationTo` is deprecated. Use `scrollResponderScrollTo` instead',\n    );\n    this.scrollResponderScrollTo({x: offsetX, y: offsetY, animated: false});\n  },\n\n  /**\n   * A helper function to zoom to a specific rect in the scrollview. The argument has the shape\n   * {x: number; y: number; width: number; height: number; animated: boolean = true}\n   *\n   * @platform ios\n   */\n  scrollResponderZoomTo: function(\n    rect: {|\n      x: number,\n      y: number,\n      width: number,\n      height: number,\n      animated?: boolean,\n    |},\n    animated?: boolean, // deprecated, put this inside the rect argument instead\n  ) {\n    invariant(\n      ScrollViewManager && ScrollViewManager.zoomToRect,\n      'zoomToRect is not implemented',\n    );\n    if ('animated' in rect) {\n      animated = rect.animated;\n      delete rect.animated;\n    } else if (typeof animated !== 'undefined') {\n      console.warn(\n        '`scrollResponderZoomTo` `animated` argument is deprecated. Use `options.animated` instead',\n      );\n    }\n    ScrollViewManager.zoomToRect(\n      this.scrollResponderGetScrollableNode(),\n      rect,\n      animated !== false,\n    );\n  },\n\n  /**\n   * Displays the scroll indicators momentarily.\n   */\n  scrollResponderFlashScrollIndicators: function() {\n    UIManager.dispatchViewManagerCommand(\n      this.scrollResponderGetScrollableNode(),\n      UIManager.RCTScrollView.Commands.flashScrollIndicators,\n      [],\n    );\n  },\n\n  /**\n   * This method should be used as the callback to onFocus in a TextInputs'\n   * parent view. Note that any module using this mixin needs to return\n   * the parent view's ref in getScrollViewRef() in order to use this method.\n   * @param {any} nodeHandle The TextInput node handle\n   * @param {number} additionalOffset The scroll view's bottom \"contentInset\".\n   *        Default is 0.\n   * @param {bool} preventNegativeScrolling Whether to allow pulling the content\n   *        down to make it meet the keyboard's top. Default is false.\n   */\n  scrollResponderScrollNativeHandleToKeyboard: function(\n    nodeHandle: any,\n    additionalOffset?: number,\n    preventNegativeScrollOffset?: boolean,\n  ) {\n    this.additionalScrollOffset = additionalOffset || 0;\n    this.preventNegativeScrollOffset = !!preventNegativeScrollOffset;\n    UIManager.measureLayout(\n      nodeHandle,\n      ReactNative.findNodeHandle(this.getInnerViewNode()),\n      this.scrollResponderTextInputFocusError,\n      this.scrollResponderInputMeasureAndScrollToKeyboard,\n    );\n  },\n\n  /**\n   * The calculations performed here assume the scroll view takes up the entire\n   * screen - even if has some content inset. We then measure the offsets of the\n   * keyboard, and compensate both for the scroll view's \"contentInset\".\n   *\n   * @param {number} left Position of input w.r.t. table view.\n   * @param {number} top Position of input w.r.t. table view.\n   * @param {number} width Width of the text input.\n   * @param {number} height Height of the text input.\n   */\n  scrollResponderInputMeasureAndScrollToKeyboard: function(\n    left: number,\n    top: number,\n    width: number,\n    height: number,\n  ) {\n    let keyboardScreenY = Dimensions.get('window').height;\n    if (this.keyboardWillOpenTo) {\n      keyboardScreenY = this.keyboardWillOpenTo.endCoordinates.screenY;\n    }\n    let scrollOffsetY =\n      top - keyboardScreenY + height + this.additionalScrollOffset;\n\n    // By default, this can scroll with negative offset, pulling the content\n    // down so that the target component's bottom meets the keyboard's top.\n    // If requested otherwise, cap the offset at 0 minimum to avoid content\n    // shifting down.\n    if (this.preventNegativeScrollOffset) {\n      scrollOffsetY = Math.max(0, scrollOffsetY);\n    }\n    this.scrollResponderScrollTo({x: 0, y: scrollOffsetY, animated: true});\n\n    this.additionalOffset = 0;\n    this.preventNegativeScrollOffset = false;\n  },\n\n  scrollResponderTextInputFocusError: function(e: Event) {\n    console.error('Error measuring text field: ', e);\n  },\n\n  /**\n   * `componentWillMount` is the closest thing to a  standard \"constructor\" for\n   * React components.\n   *\n   * The `keyboardWillShow` is called before input focus.\n   */\n  UNSAFE_componentWillMount: function() {\n    const {keyboardShouldPersistTaps} = this.props;\n    warning(\n      typeof keyboardShouldPersistTaps !== 'boolean',\n      `'keyboardShouldPersistTaps={${keyboardShouldPersistTaps}}' is deprecated. ` +\n        `Use 'keyboardShouldPersistTaps=\"${\n          keyboardShouldPersistTaps ? 'always' : 'never'\n        }\"' instead`,\n    );\n\n    this.keyboardWillOpenTo = null;\n    this.additionalScrollOffset = 0;\n    this.addListenerOn(\n      Keyboard,\n      'keyboardWillShow',\n      this.scrollResponderKeyboardWillShow,\n    );\n    this.addListenerOn(\n      Keyboard,\n      'keyboardWillHide',\n      this.scrollResponderKeyboardWillHide,\n    );\n    this.addListenerOn(\n      Keyboard,\n      'keyboardDidShow',\n      this.scrollResponderKeyboardDidShow,\n    );\n    this.addListenerOn(\n      Keyboard,\n      'keyboardDidHide',\n      this.scrollResponderKeyboardDidHide,\n    );\n  },\n\n  /**\n   * Warning, this may be called several times for a single keyboard opening.\n   * It's best to store the information in this method and then take any action\n   * at a later point (either in `keyboardDidShow` or other).\n   *\n   * Here's the order that events occur in:\n   * - focus\n   * - willShow {startCoordinates, endCoordinates} several times\n   * - didShow several times\n   * - blur\n   * - willHide {startCoordinates, endCoordinates} several times\n   * - didHide several times\n   *\n   * The `ScrollResponder` module callbacks for each of these events.\n   * Even though any user could have easily listened to keyboard events\n   * themselves, using these `props` callbacks ensures that ordering of events\n   * is consistent - and not dependent on the order that the keyboard events are\n   * subscribed to. This matters when telling the scroll view to scroll to where\n   * the keyboard is headed - the scroll responder better have been notified of\n   * the keyboard destination before being instructed to scroll to where the\n   * keyboard will be. Stick to the `ScrollResponder` callbacks, and everything\n   * will work.\n   *\n   * WARNING: These callbacks will fire even if a keyboard is displayed in a\n   * different navigation pane. Filter out the events to determine if they are\n   * relevant to you. (For example, only if you receive these callbacks after\n   * you had explicitly focused a node etc).\n   */\n  scrollResponderKeyboardWillShow: function(e: Event) {\n    this.keyboardWillOpenTo = e;\n    this.props.onKeyboardWillShow && this.props.onKeyboardWillShow(e);\n  },\n\n  scrollResponderKeyboardWillHide: function(e: Event) {\n    this.keyboardWillOpenTo = null;\n    this.props.onKeyboardWillHide && this.props.onKeyboardWillHide(e);\n  },\n\n  scrollResponderKeyboardDidShow: function(e: Event) {\n    // TODO(7693961): The event for DidShow is not available on iOS yet.\n    // Use the one from WillShow and do not assign.\n    if (e) {\n      this.keyboardWillOpenTo = e;\n    }\n    this.props.onKeyboardDidShow && this.props.onKeyboardDidShow(e);\n  },\n\n  scrollResponderKeyboardDidHide: function(e: Event) {\n    this.keyboardWillOpenTo = null;\n    this.props.onKeyboardDidHide && this.props.onKeyboardDidHide(e);\n  },\n};\n\nconst ScrollResponder = {\n  Mixin: ScrollResponderMixin,\n};\n\nmodule.exports = ScrollResponder;\n"]}]}