{"remainingRequest":"/Users/jeffrey/HaulTesting/node_modules/thread-loader/dist/cjs.js??ref--5-1!/Users/jeffrey/HaulTesting/node_modules/babel-loader/lib/index.js??ref--5-2!/Users/jeffrey/HaulTesting/node_modules/react-native/Libraries/Utilities/createStrictShapeTypeChecker.js","dependencies":[{"path":"/Users/jeffrey/HaulTesting/node_modules/react-native/Libraries/Utilities/createStrictShapeTypeChecker.js","mtime":1539700108130},{"path":"/Users/jeffrey/HaulTesting/node_modules/cache-loader/dist/cjs.js","mtime":1539652983212},{"path":"/Users/jeffrey/HaulTesting/node_modules/thread-loader/dist/cjs.js","mtime":1539652983315},{"path":"/Users/jeffrey/HaulTesting/node_modules/babel-loader/lib/index.js","mtime":1539615827828}],"contextDependencies":[],"result":["'use strict';(function(){var enterModule=require('react-hot-loader').enterModule;enterModule&&enterModule(module);})();var invariant=require('fbjs/lib/invariant');var merge=require('merge');function createStrictShapeTypeChecker(shapeTypes){function checkType(isRequired,props,propName,componentName,location){if(!props[propName]){if(isRequired){invariant(false,\"Required object `\"+propName+\"` was not specified in \"+(\"`\"+componentName+\"`.\"));}return;}var propValue=props[propName];var propType=typeof propValue;var locationName=location||'(unknown)';if(propType!=='object'){invariant(false,\"Invalid \"+locationName+\" `\"+propName+\"` of type `\"+propType+\"` \"+(\"supplied to `\"+componentName+\"`, expected `object`.\"));}var allKeys=merge(props[propName],shapeTypes);for(var _len=arguments.length,rest=new Array(_len>5?_len-5:0),_key=5;_key<_len;_key++){rest[_key-5]=arguments[_key];}for(var _key2 in allKeys){var checker=shapeTypes[_key2];if(!checker){invariant(false,\"Invalid props.\"+propName+\" key `\"+_key2+\"` supplied to `\"+componentName+\"`.\"+'\\nBad object: '+JSON.stringify(props[propName],null,'  ')+'\\nValid keys: '+JSON.stringify(Object.keys(shapeTypes),null,'  '));}var error=checker.apply(void 0,[propValue,_key2,componentName,location].concat(rest));if(error){invariant(false,error.message+'\\nBad object: '+JSON.stringify(props[propName],null,'  '));}}}function chainedCheckType(props,propName,componentName,location){for(var _len2=arguments.length,rest=new Array(_len2>4?_len2-4:0),_key3=4;_key3<_len2;_key3++){rest[_key3-4]=arguments[_key3];}return checkType.apply(void 0,[false,props,propName,componentName,location].concat(rest));}chainedCheckType.isRequired=checkType.bind(null,true);return chainedCheckType;}module.exports=createStrictShapeTypeChecker;;(function(){var reactHotLoader=require('react-hot-loader').default;var leaveModule=require('react-hot-loader').leaveModule;if(!reactHotLoader){return;}reactHotLoader.register(createStrictShapeTypeChecker,\"createStrictShapeTypeChecker\",\"/Users/jeffrey/HaulTesting/node_modules/react-native/Libraries/Utilities/createStrictShapeTypeChecker.js\");leaveModule(module);})();;",{"version":3,"sources":["/Users/jeffrey/HaulTesting/node_modules/react-native/Libraries/Utilities/createStrictShapeTypeChecker.js"],"names":["invariant","require","merge","createStrictShapeTypeChecker","shapeTypes","checkType","isRequired","props","propName","componentName","location","propValue","propType","locationName","allKeys","rest","key","checker","JSON","stringify","Object","keys","error","message","chainedCheckType","bind","module","exports"],"mappings":"AAUA,a,0GAEA,GAAMA,CAAAA,SAAS,CAAGC,OAAO,CAAC,oBAAD,CAAzB,CACA,GAAMC,CAAAA,KAAK,CAAGD,OAAO,CAAC,OAAD,CAArB,CAEA,QAASE,CAAAA,4BAAT,CAAsCC,UAAtC,CAEmC,CACjC,QAASC,CAAAA,SAAT,CACEC,UADF,CAEEC,KAFF,CAGEC,QAHF,CAIEC,aAJF,CAKEC,QALF,CAOE,CACA,GAAI,CAACH,KAAK,CAACC,QAAD,CAAV,CAAsB,CACpB,GAAIF,UAAJ,CAAgB,CACdN,SAAS,CACP,KADO,CAEP,oBAAqBQ,QAArB,gCACOC,aADP,MAFO,CAAT,CAKD,CACD,OACD,CACD,GAAME,CAAAA,SAAS,CAAGJ,KAAK,CAACC,QAAD,CAAvB,CACA,GAAMI,CAAAA,QAAQ,CAAG,MAAOD,CAAAA,SAAxB,CACA,GAAME,CAAAA,YAAY,CAAGH,QAAQ,EAAI,WAAjC,CACA,GAAIE,QAAQ,GAAK,QAAjB,CAA2B,CACzBZ,SAAS,CACP,KADO,CAEP,WAAWa,YAAX,MAA6BL,QAA7B,eAAqDI,QAArD,uBACmBH,aADnB,yBAFO,CAAT,CAKD,CAGD,GAAMK,CAAAA,OAAO,CAAGZ,KAAK,CAACK,KAAK,CAACC,QAAD,CAAN,CAAkBJ,UAAlB,CAArB,CAvBA,8BADGW,IACH,qDADGA,IACH,0BAwBA,IAAK,GAAMC,CAAAA,KAAX,GAAkBF,CAAAA,OAAlB,CAA2B,CACzB,GAAMG,CAAAA,OAAO,CAAGb,UAAU,CAACY,KAAD,CAA1B,CACA,GAAI,CAACC,OAAL,CAAc,CACZjB,SAAS,CACP,KADO,CAEP,iBAAiBQ,QAAjB,UAAmCQ,KAAnC,mBAA0DP,aAA1D,MACE,gBADF,CAEES,IAAI,CAACC,SAAL,CAAeZ,KAAK,CAACC,QAAD,CAApB,CAAgC,IAAhC,CAAsC,IAAtC,CAFF,CAGE,gBAHF,CAIEU,IAAI,CAACC,SAAL,CAAeC,MAAM,CAACC,IAAP,CAAYjB,UAAZ,CAAf,CAAwC,IAAxC,CAA8C,IAA9C,CANK,CAAT,CAQD,CACD,GAAMkB,CAAAA,KAAK,CAAGL,OAAO,MAAP,SAAQN,SAAR,CAAmBK,KAAnB,CAAwBP,aAAxB,CAAuCC,QAAvC,SAAoDK,IAApD,EAAd,CACA,GAAIO,KAAJ,CAAW,CACTtB,SAAS,CACP,KADO,CAEPsB,KAAK,CAACC,OAAN,CACE,gBADF,CAEEL,IAAI,CAACC,SAAL,CAAeZ,KAAK,CAACC,QAAD,CAApB,CAAgC,IAAhC,CAAsC,IAAtC,CAJK,CAAT,CAMD,CACF,CACF,CACD,QAASgB,CAAAA,gBAAT,CACEjB,KADF,CAEEC,QAFF,CAGEC,aAHF,CAIEC,QAJF,CAMU,gCADLK,IACK,2DADLA,IACK,4BACR,MAAOV,CAAAA,SAAS,MAAT,SAAU,KAAV,CAAiBE,KAAjB,CAAwBC,QAAxB,CAAkCC,aAAlC,CAAiDC,QAAjD,SAA8DK,IAA9D,EAAP,CACD,CACDS,gBAAgB,CAAClB,UAAjB,CAA8BD,SAAS,CAACoB,IAAV,CAAe,IAAf,CAAqB,IAArB,CAA9B,CACA,MAAOD,CAAAA,gBAAP,CACD,CAEDE,MAAM,CAACC,OAAP,CAAiBxB,4BAAjB,C,gLAtESA,4B","sourcesContent":["/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @format\n * @flow\n */\n\n'use strict';\n\nconst invariant = require('fbjs/lib/invariant');\nconst merge = require('merge');\n\nfunction createStrictShapeTypeChecker(shapeTypes: {\n  [key: string]: ReactPropsCheckType,\n}): ReactPropsChainableTypeChecker {\n  function checkType(\n    isRequired,\n    props,\n    propName,\n    componentName,\n    location?,\n    ...rest\n  ) {\n    if (!props[propName]) {\n      if (isRequired) {\n        invariant(\n          false,\n          `Required object \\`${propName}\\` was not specified in ` +\n            `\\`${componentName}\\`.`,\n        );\n      }\n      return;\n    }\n    const propValue = props[propName];\n    const propType = typeof propValue;\n    const locationName = location || '(unknown)';\n    if (propType !== 'object') {\n      invariant(\n        false,\n        `Invalid ${locationName} \\`${propName}\\` of type \\`${propType}\\` ` +\n          `supplied to \\`${componentName}\\`, expected \\`object\\`.`,\n      );\n    }\n    // We need to check all keys in case some are required but missing from\n    // props.\n    const allKeys = merge(props[propName], shapeTypes);\n    for (const key in allKeys) {\n      const checker = shapeTypes[key];\n      if (!checker) {\n        invariant(\n          false,\n          `Invalid props.${propName} key \\`${key}\\` supplied to \\`${componentName}\\`.` +\n            '\\nBad object: ' +\n            JSON.stringify(props[propName], null, '  ') +\n            '\\nValid keys: ' +\n            JSON.stringify(Object.keys(shapeTypes), null, '  '),\n        );\n      }\n      const error = checker(propValue, key, componentName, location, ...rest);\n      if (error) {\n        invariant(\n          false,\n          error.message +\n            '\\nBad object: ' +\n            JSON.stringify(props[propName], null, '  '),\n        );\n      }\n    }\n  }\n  function chainedCheckType(\n    props: {[key: string]: any},\n    propName: string,\n    componentName: string,\n    location?: string,\n    ...rest\n  ): ?Error {\n    return checkType(false, props, propName, componentName, location, ...rest);\n  }\n  chainedCheckType.isRequired = checkType.bind(null, true);\n  return chainedCheckType;\n}\n\nmodule.exports = createStrictShapeTypeChecker;\n"]}]}