{"remainingRequest":"/Users/jeffrey/HaulTesting/node_modules/thread-loader/dist/cjs.js??ref--5-1!/Users/jeffrey/HaulTesting/node_modules/babel-loader/lib/index.js??ref--5-2!/Users/jeffrey/HaulTesting/node_modules/react-native/Libraries/Components/ScrollView/ScrollView.js","dependencies":[{"path":"/Users/jeffrey/HaulTesting/node_modules/react-native/Libraries/Components/ScrollView/ScrollView.js","mtime":1539700108130},{"path":"/Users/jeffrey/HaulTesting/node_modules/cache-loader/dist/cjs.js","mtime":1539652983212},{"path":"/Users/jeffrey/HaulTesting/node_modules/thread-loader/dist/cjs.js","mtime":1539652983315},{"path":"/Users/jeffrey/HaulTesting/node_modules/babel-loader/lib/index.js","mtime":1539615827828}],"contextDependencies":[],"result":["'use strict';var _interopRequireDefault=require(\"@babel/runtime/helpers/interopRequireDefault\");var _extends2=_interopRequireDefault(require(\"@babel/runtime/helpers/extends\"));var _objectSpread2=_interopRequireDefault(require(\"@babel/runtime/helpers/objectSpread\"));var _jsxFileName=\"/Users/jeffrey/HaulTesting/node_modules/react-native/Libraries/Components/ScrollView/ScrollView.js\";(function(){var enterModule=require('react-hot-loader').enterModule;enterModule&&enterModule(module);})();var AnimatedImplementation=require('AnimatedImplementation');var Platform=require('Platform');var React=require('React');var ReactNative=require('ReactNative');var ScrollResponder=require('ScrollResponder');var ScrollViewStickyHeader=require('ScrollViewStickyHeader');var StyleSheet=require('StyleSheet');var View=require('View');var InternalScrollViewType=require('InternalScrollViewType');var createReactClass=require('create-react-class');var dismissKeyboard=require('dismissKeyboard');var flattenStyle=require('flattenStyle');var invariant=require('fbjs/lib/invariant');var processDecelerationRate=require('processDecelerationRate');var requireNativeComponent=require('requireNativeComponent');var warning=require('fbjs/lib/warning');var resolveAssetSource=require('resolveAssetSource');var AndroidScrollView;var AndroidHorizontalScrollContentView;var AndroidHorizontalScrollView;var RCTScrollView;var RCTScrollContentView;if(Platform.OS==='android'){AndroidScrollView=requireNativeComponent('RCTScrollView');AndroidHorizontalScrollView=requireNativeComponent('AndroidHorizontalScrollView');AndroidHorizontalScrollContentView=requireNativeComponent('AndroidHorizontalScrollContentView');}else if(Platform.OS==='ios'){RCTScrollView=requireNativeComponent('RCTScrollView');RCTScrollContentView=requireNativeComponent('RCTScrollContentView');}else{RCTScrollView=requireNativeComponent('RCTScrollView');RCTScrollContentView=requireNativeComponent('RCTScrollContentView');}var ScrollView=createReactClass({displayName:'ScrollView',mixins:[ScrollResponder.Mixin],_scrollAnimatedValue:new AnimatedImplementation.Value(0),_scrollAnimatedValueAttachment:null,_stickyHeaderRefs:new Map(),_headerLayoutYs:new Map(),getInitialState:function getInitialState(){return(0,_objectSpread2.default)({},this.scrollResponderMixinGetInitialState(),{layoutHeight:null});},UNSAFE_componentWillMount:function UNSAFE_componentWillMount(){this._scrollAnimatedValue=new AnimatedImplementation.Value(this.props.contentOffset?this.props.contentOffset.y:0);this._scrollAnimatedValue.setOffset(this.props.contentInset?this.props.contentInset.top:0);this._stickyHeaderRefs=new Map();this._headerLayoutYs=new Map();},componentDidMount:function componentDidMount(){this._updateAnimatedNodeAttachment();},componentDidUpdate:function componentDidUpdate(){this._updateAnimatedNodeAttachment();},componentWillUnmount:function componentWillUnmount(){if(this._scrollAnimatedValueAttachment){this._scrollAnimatedValueAttachment.detach();}},setNativeProps:function setNativeProps(props){this._scrollViewRef&&this._scrollViewRef.setNativeProps(props);},getScrollResponder:function getScrollResponder(){return this;},getScrollableNode:function getScrollableNode(){return ReactNative.findNodeHandle(this._scrollViewRef);},getInnerViewNode:function getInnerViewNode(){return ReactNative.findNodeHandle(this._innerViewRef);},scrollTo:function scrollTo(y,x,animated){if(typeof y==='number'){console.warn('`scrollTo(y, x, animated)` is deprecated. Use `scrollTo({x: 5, y: 5, '+'animated: true})` instead.');}else{var _ref=y||{};x=_ref.x;y=_ref.y;animated=_ref.animated;}this.getScrollResponder().scrollResponderScrollTo({x:x||0,y:y||0,animated:animated!==false});},scrollToEnd:function scrollToEnd(options){var animated=(options&&options.animated)!==false;this.getScrollResponder().scrollResponderScrollToEnd({animated:animated});},scrollWithoutAnimationTo:function scrollWithoutAnimationTo(){var y=arguments.length>0&&arguments[0]!==undefined?arguments[0]:0;var x=arguments.length>1&&arguments[1]!==undefined?arguments[1]:0;console.warn('`scrollWithoutAnimationTo` is deprecated. Use `scrollTo` instead');this.scrollTo({x:x,y:y,animated:false});},flashScrollIndicators:function flashScrollIndicators(){this.getScrollResponder().scrollResponderFlashScrollIndicators();},_getKeyForIndex:function _getKeyForIndex(index,childArray){var child=childArray[index];return child&&child.key;},_updateAnimatedNodeAttachment:function _updateAnimatedNodeAttachment(){if(this._scrollAnimatedValueAttachment){this._scrollAnimatedValueAttachment.detach();}if(this.props.stickyHeaderIndices&&this.props.stickyHeaderIndices.length>0){this._scrollAnimatedValueAttachment=AnimatedImplementation.attachNativeEvent(this._scrollViewRef,'onScroll',[{nativeEvent:{contentOffset:{y:this._scrollAnimatedValue}}}]);}},_setStickyHeaderRef:function _setStickyHeaderRef(key,ref){if(ref){this._stickyHeaderRefs.set(key,ref);}else{this._stickyHeaderRefs.delete(key);}},_onStickyHeaderLayout:function _onStickyHeaderLayout(index,event,key){if(!this.props.stickyHeaderIndices){return;}var childArray=React.Children.toArray(this.props.children);if(key!==this._getKeyForIndex(index,childArray)){return;}var layoutY=event.nativeEvent.layout.y;this._headerLayoutYs.set(key,layoutY);var indexOfIndex=this.props.stickyHeaderIndices.indexOf(index);var previousHeaderIndex=this.props.stickyHeaderIndices[indexOfIndex-1];if(previousHeaderIndex!=null){var previousHeader=this._stickyHeaderRefs.get(this._getKeyForIndex(previousHeaderIndex,childArray));previousHeader&&previousHeader.setNextHeaderY(layoutY);}},_handleScroll:function _handleScroll(e){if(__DEV__){if(this.props.onScroll&&this.props.scrollEventThrottle==null&&Platform.OS==='ios'){console.log('You specified `onScroll` on a <ScrollView> but not '+'`scrollEventThrottle`. You will only receive one event. '+'Using `16` you get all the events but be aware that it may '+\"cause frame drops, use a bigger number if you don't need as \"+'much precision.');}}if(Platform.OS==='android'){if(this.props.keyboardDismissMode==='on-drag'&&this.state.isTouching){dismissKeyboard();}}this.scrollResponderHandleScroll(e);},_handleLayout:function _handleLayout(e){if(this.props.invertStickyHeaders){this.setState({layoutHeight:e.nativeEvent.layout.height});}if(this.props.onLayout){this.props.onLayout(e);}},_handleContentOnLayout:function _handleContentOnLayout(e){var _e$nativeEvent$layout=e.nativeEvent.layout,width=_e$nativeEvent$layout.width,height=_e$nativeEvent$layout.height;this.props.onContentSizeChange&&this.props.onContentSizeChange(width,height);},_scrollViewRef:null,_setScrollViewRef:function _setScrollViewRef(ref){this._scrollViewRef=ref;},_innerViewRef:null,_setInnerViewRef:function _setInnerViewRef(ref){this._innerViewRef=ref;},render:function render(){var _this=this;var ScrollViewClass;var ScrollContentContainerViewClass;if(Platform.OS==='android'){if(this.props.horizontal){ScrollViewClass=AndroidHorizontalScrollView;ScrollContentContainerViewClass=AndroidHorizontalScrollContentView;}else{ScrollViewClass=AndroidScrollView;ScrollContentContainerViewClass=View;}}else{ScrollViewClass=RCTScrollView;ScrollContentContainerViewClass=RCTScrollContentView;}invariant(ScrollViewClass!==undefined,'ScrollViewClass must not be undefined');invariant(ScrollContentContainerViewClass!==undefined,'ScrollContentContainerViewClass must not be undefined');var contentContainerStyle=[this.props.horizontal&&styles.contentContainerHorizontal,this.props.contentContainerStyle];if(__DEV__&&this.props.style){var style=flattenStyle(this.props.style);var childLayoutProps=['alignItems','justifyContent'].filter(function(prop){return style&&style[prop]!==undefined;});invariant(childLayoutProps.length===0,'ScrollView child layout ('+JSON.stringify(childLayoutProps)+') must be applied through the contentContainerStyle prop.');}var contentSizeChangeProps={};if(this.props.onContentSizeChange){contentSizeChangeProps={onLayout:this._handleContentOnLayout};}var stickyHeaderIndices=this.props.stickyHeaderIndices;var hasStickyHeaders=stickyHeaderIndices&&stickyHeaderIndices.length>0;var childArray=hasStickyHeaders&&React.Children.toArray(this.props.children);var children=hasStickyHeaders?childArray.map(function(child,index){var indexOfIndex=child?stickyHeaderIndices.indexOf(index):-1;if(indexOfIndex>-1){var key=child.key;var nextIndex=stickyHeaderIndices[indexOfIndex+1];return React.createElement(ScrollViewStickyHeader,{key:key,ref:function ref(_ref2){return _this._setStickyHeaderRef(key,_ref2);},nextHeaderLayoutY:_this._headerLayoutYs.get(_this._getKeyForIndex(nextIndex,childArray)),onLayout:function onLayout(event){return _this._onStickyHeaderLayout(index,event,key);},scrollAnimatedValue:_this._scrollAnimatedValue,inverted:_this.props.invertStickyHeaders,scrollViewHeight:_this.state.layoutHeight,__source:{fileName:_jsxFileName,lineNumber:831}},child);}else{return child;}}):this.props.children;var contentContainer=React.createElement(ScrollContentContainerViewClass,(0,_extends2.default)({},contentSizeChangeProps,{ref:this._setInnerViewRef,style:contentContainerStyle,removeClippedSubviews:Platform.OS==='android'&&hasStickyHeaders?false:this.props.removeClippedSubviews,collapsable:false,__source:{fileName:_jsxFileName,lineNumber:852}}),children);var alwaysBounceHorizontal=this.props.alwaysBounceHorizontal!==undefined?this.props.alwaysBounceHorizontal:this.props.horizontal;var alwaysBounceVertical=this.props.alwaysBounceVertical!==undefined?this.props.alwaysBounceVertical:!this.props.horizontal;var DEPRECATED_sendUpdatedChildFrames=!!this.props.DEPRECATED_sendUpdatedChildFrames;var baseStyle=this.props.horizontal?styles.baseHorizontal:styles.baseVertical;var props=(0,_objectSpread2.default)({},this.props,{alwaysBounceHorizontal:alwaysBounceHorizontal,alwaysBounceVertical:alwaysBounceVertical,style:[baseStyle,this.props.style],onContentSizeChange:null,onLayout:this._handleLayout,onMomentumScrollBegin:this.scrollResponderHandleMomentumScrollBegin,onMomentumScrollEnd:this.scrollResponderHandleMomentumScrollEnd,onResponderGrant:this.scrollResponderHandleResponderGrant,onResponderReject:this.scrollResponderHandleResponderReject,onResponderRelease:this.scrollResponderHandleResponderRelease,onResponderTerminate:this.scrollResponderHandleTerminate,onResponderTerminationRequest:this.scrollResponderHandleTerminationRequest,onScroll:this._handleScroll,onScrollBeginDrag:this.scrollResponderHandleScrollBeginDrag,onScrollEndDrag:this.scrollResponderHandleScrollEndDrag,onScrollShouldSetResponder:this.scrollResponderHandleScrollShouldSetResponder,onStartShouldSetResponder:this.scrollResponderHandleStartShouldSetResponder,onStartShouldSetResponderCapture:this.scrollResponderHandleStartShouldSetResponderCapture,onTouchEnd:this.scrollResponderHandleTouchEnd,onTouchMove:this.scrollResponderHandleTouchMove,onTouchStart:this.scrollResponderHandleTouchStart,onTouchCancel:this.scrollResponderHandleTouchCancel,scrollBarThumbImage:resolveAssetSource(this.props.scrollBarThumbImage),scrollEventThrottle:hasStickyHeaders?1:this.props.scrollEventThrottle,sendMomentumEvents:this.props.onMomentumScrollBegin||this.props.onMomentumScrollEnd?true:false,DEPRECATED_sendUpdatedChildFrames:DEPRECATED_sendUpdatedChildFrames,pagingEnabled:Platform.select({ios:this.props.pagingEnabled&&this.props.snapToInterval==null&&this.props.snapToOffsets==null,android:this.props.pagingEnabled||this.props.snapToInterval!=null||this.props.snapToOffsets!=null})});var decelerationRate=this.props.decelerationRate;if(decelerationRate!=null){props.decelerationRate=processDecelerationRate(decelerationRate);}var refreshControl=this.props.refreshControl;if(refreshControl){if(Platform.OS==='ios'){return React.createElement(ScrollViewClass,(0,_extends2.default)({},props,{ref:this._setScrollViewRef,__source:{fileName:_jsxFileName,lineNumber:952}}),Platform.isTV?null:refreshControl,contentContainer);}else if(Platform.OS==='android'){return React.cloneElement(refreshControl,{style:props.style},React.createElement(ScrollViewClass,(0,_extends2.default)({},props,{style:baseStyle,ref:this._setScrollViewRef,__source:{fileName:_jsxFileName,lineNumber:967}}),contentContainer));}}return React.createElement(ScrollViewClass,(0,_extends2.default)({},props,{ref:this._setScrollViewRef,__source:{fileName:_jsxFileName,lineNumber:977}}),contentContainer);}});var TypedScrollView=ScrollView;var styles=StyleSheet.create({baseVertical:{flexGrow:1,flexShrink:1,flexDirection:'column',overflow:'scroll'},baseHorizontal:{flexGrow:1,flexShrink:1,flexDirection:'row',overflow:'scroll'},contentContainerHorizontal:{flexDirection:'row'}});module.exports=TypedScrollView;;(function(){var reactHotLoader=require('react-hot-loader').default;var leaveModule=require('react-hot-loader').leaveModule;if(!reactHotLoader){return;}reactHotLoader.register(AndroidScrollView,\"AndroidScrollView\",\"/Users/jeffrey/HaulTesting/node_modules/react-native/Libraries/Components/ScrollView/ScrollView.js\");reactHotLoader.register(AndroidHorizontalScrollContentView,\"AndroidHorizontalScrollContentView\",\"/Users/jeffrey/HaulTesting/node_modules/react-native/Libraries/Components/ScrollView/ScrollView.js\");reactHotLoader.register(AndroidHorizontalScrollView,\"AndroidHorizontalScrollView\",\"/Users/jeffrey/HaulTesting/node_modules/react-native/Libraries/Components/ScrollView/ScrollView.js\");reactHotLoader.register(RCTScrollView,\"RCTScrollView\",\"/Users/jeffrey/HaulTesting/node_modules/react-native/Libraries/Components/ScrollView/ScrollView.js\");reactHotLoader.register(RCTScrollContentView,\"RCTScrollContentView\",\"/Users/jeffrey/HaulTesting/node_modules/react-native/Libraries/Components/ScrollView/ScrollView.js\");reactHotLoader.register(ScrollView,\"ScrollView\",\"/Users/jeffrey/HaulTesting/node_modules/react-native/Libraries/Components/ScrollView/ScrollView.js\");reactHotLoader.register(TypedScrollView,\"TypedScrollView\",\"/Users/jeffrey/HaulTesting/node_modules/react-native/Libraries/Components/ScrollView/ScrollView.js\");reactHotLoader.register(styles,\"styles\",\"/Users/jeffrey/HaulTesting/node_modules/react-native/Libraries/Components/ScrollView/ScrollView.js\");leaveModule(module);})();;",{"version":3,"sources":["/Users/jeffrey/HaulTesting/node_modules/react-native/Libraries/Components/ScrollView/ScrollView.js"],"names":["AnimatedImplementation","require","Platform","React","ReactNative","ScrollResponder","ScrollViewStickyHeader","StyleSheet","View","InternalScrollViewType","createReactClass","dismissKeyboard","flattenStyle","invariant","processDecelerationRate","requireNativeComponent","warning","resolveAssetSource","AndroidScrollView","AndroidHorizontalScrollContentView","AndroidHorizontalScrollView","RCTScrollView","RCTScrollContentView","OS","ScrollView","displayName","mixins","Mixin","_scrollAnimatedValue","Value","_scrollAnimatedValueAttachment","_stickyHeaderRefs","Map","_headerLayoutYs","getInitialState","scrollResponderMixinGetInitialState","layoutHeight","UNSAFE_componentWillMount","props","contentOffset","y","setOffset","contentInset","top","componentDidMount","_updateAnimatedNodeAttachment","componentDidUpdate","componentWillUnmount","detach","setNativeProps","_scrollViewRef","getScrollResponder","getScrollableNode","findNodeHandle","getInnerViewNode","_innerViewRef","scrollTo","x","animated","console","warn","scrollResponderScrollTo","scrollToEnd","options","scrollResponderScrollToEnd","scrollWithoutAnimationTo","flashScrollIndicators","scrollResponderFlashScrollIndicators","_getKeyForIndex","index","childArray","child","key","stickyHeaderIndices","length","attachNativeEvent","nativeEvent","_setStickyHeaderRef","ref","set","delete","_onStickyHeaderLayout","event","Children","toArray","children","layoutY","layout","indexOfIndex","indexOf","previousHeaderIndex","previousHeader","get","setNextHeaderY","_handleScroll","e","__DEV__","onScroll","scrollEventThrottle","log","keyboardDismissMode","state","isTouching","scrollResponderHandleScroll","_handleLayout","invertStickyHeaders","setState","height","onLayout","_handleContentOnLayout","width","onContentSizeChange","_setScrollViewRef","_setInnerViewRef","render","ScrollViewClass","ScrollContentContainerViewClass","horizontal","undefined","contentContainerStyle","styles","contentContainerHorizontal","style","childLayoutProps","filter","prop","JSON","stringify","contentSizeChangeProps","hasStickyHeaders","map","nextIndex","contentContainer","removeClippedSubviews","alwaysBounceHorizontal","alwaysBounceVertical","DEPRECATED_sendUpdatedChildFrames","baseStyle","baseHorizontal","baseVertical","onMomentumScrollBegin","scrollResponderHandleMomentumScrollBegin","onMomentumScrollEnd","scrollResponderHandleMomentumScrollEnd","onResponderGrant","scrollResponderHandleResponderGrant","onResponderReject","scrollResponderHandleResponderReject","onResponderRelease","scrollResponderHandleResponderRelease","onResponderTerminate","scrollResponderHandleTerminate","onResponderTerminationRequest","scrollResponderHandleTerminationRequest","onScrollBeginDrag","scrollResponderHandleScrollBeginDrag","onScrollEndDrag","scrollResponderHandleScrollEndDrag","onScrollShouldSetResponder","scrollResponderHandleScrollShouldSetResponder","onStartShouldSetResponder","scrollResponderHandleStartShouldSetResponder","onStartShouldSetResponderCapture","scrollResponderHandleStartShouldSetResponderCapture","onTouchEnd","scrollResponderHandleTouchEnd","onTouchMove","scrollResponderHandleTouchMove","onTouchStart","scrollResponderHandleTouchStart","onTouchCancel","scrollResponderHandleTouchCancel","scrollBarThumbImage","sendMomentumEvents","pagingEnabled","select","ios","snapToInterval","snapToOffsets","android","decelerationRate","refreshControl","isTV","cloneElement","TypedScrollView","create","flexGrow","flexShrink","flexDirection","overflow","module","exports"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @format\n * @flow\n */\n\n'use strict';\n\nconst AnimatedImplementation = require('AnimatedImplementation');\nconst Platform = require('Platform');\nconst React = require('React');\nconst ReactNative = require('ReactNative');\nconst ScrollResponder = require('ScrollResponder');\nconst ScrollViewStickyHeader = require('ScrollViewStickyHeader');\nconst StyleSheet = require('StyleSheet');\nconst View = require('View');\nconst InternalScrollViewType = require('InternalScrollViewType');\n\nconst createReactClass = require('create-react-class');\nconst dismissKeyboard = require('dismissKeyboard');\nconst flattenStyle = require('flattenStyle');\nconst invariant = require('fbjs/lib/invariant');\nconst processDecelerationRate = require('processDecelerationRate');\nconst requireNativeComponent = require('requireNativeComponent');\nconst warning = require('fbjs/lib/warning');\nconst resolveAssetSource = require('resolveAssetSource');\n\nimport type {PressEvent} from 'CoreEventTypes';\nimport type {EdgeInsetsProp} from 'EdgeInsetsPropType';\nimport type {NativeMethodsMixinType} from 'ReactNativeTypes';\nimport type {ViewStyleProp} from 'StyleSheet';\nimport type {ViewProps} from 'ViewPropTypes';\nimport type {PointProp} from 'PointPropType';\n\nimport type {ColorValue} from 'StyleSheetTypes';\n\nlet AndroidScrollView;\nlet AndroidHorizontalScrollContentView;\nlet AndroidHorizontalScrollView;\nlet RCTScrollView;\nlet RCTScrollContentView;\n\nif (Platform.OS === 'android') {\n  AndroidScrollView = requireNativeComponent('RCTScrollView');\n  AndroidHorizontalScrollView = requireNativeComponent(\n    'AndroidHorizontalScrollView',\n  );\n  AndroidHorizontalScrollContentView = requireNativeComponent(\n    'AndroidHorizontalScrollContentView',\n  );\n} else if (Platform.OS === 'ios') {\n  RCTScrollView = requireNativeComponent('RCTScrollView');\n  RCTScrollContentView = requireNativeComponent('RCTScrollContentView');\n} else {\n  RCTScrollView = requireNativeComponent('RCTScrollView');\n  RCTScrollContentView = requireNativeComponent('RCTScrollContentView');\n}\n\ntype TouchableProps = $ReadOnly<{|\n  onTouchStart?: (event: PressEvent) => void,\n  onTouchMove?: (event: PressEvent) => void,\n  onTouchEnd?: (event: PressEvent) => void,\n  onTouchCancel?: (event: PressEvent) => void,\n  onTouchEndCapture?: (event: PressEvent) => void,\n|}>;\n\ntype IOSProps = $ReadOnly<{|\n  /**\n   * Controls whether iOS should automatically adjust the content inset\n   * for scroll views that are placed behind a navigation bar or\n   * tab bar/ toolbar. The default value is true.\n   * @platform ios\n   */\n  automaticallyAdjustContentInsets?: ?boolean,\n  /**\n   * The amount by which the scroll view content is inset from the edges\n   * of the scroll view. Defaults to `{top: 0, left: 0, bottom: 0, right: 0}`.\n   * @platform ios\n   */\n  contentInset?: ?EdgeInsetsProp,\n  /**\n   * Used to manually set the starting scroll offset.\n   * The default value is `{x: 0, y: 0}`.\n   * @platform ios\n   */\n  contentOffset?: ?PointProp,\n  /**\n   * When true, the scroll view bounces when it reaches the end of the\n   * content if the content is larger then the scroll view along the axis of\n   * the scroll direction. When false, it disables all bouncing even if\n   * the `alwaysBounce*` props are true. The default value is true.\n   * @platform ios\n   */\n  bounces?: ?boolean,\n  /**\n   * When true, gestures can drive zoom past min/max and the zoom will animate\n   * to the min/max value at gesture end, otherwise the zoom will not exceed\n   * the limits.\n   * @platform ios\n   */\n  bouncesZoom?: ?boolean,\n  /**\n   * When true, the scroll view bounces horizontally when it reaches the end\n   * even if the content is smaller than the scroll view itself. The default\n   * value is true when `horizontal={true}` and false otherwise.\n   * @platform ios\n   */\n  alwaysBounceHorizontal?: ?boolean,\n  /**\n   * When true, the scroll view bounces vertically when it reaches the end\n   * even if the content is smaller than the scroll view itself. The default\n   * value is false when `horizontal={true}` and true otherwise.\n   * @platform ios\n   */\n  alwaysBounceVertical?: ?boolean,\n  /**\n   * When true, the scroll view automatically centers the content when the\n   * content is smaller than the scroll view bounds; when the content is\n   * larger than the scroll view, this property has no effect. The default\n   * value is false.\n   * @platform ios\n   */\n  centerContent?: ?boolean,\n  /**\n   * The style of the scroll indicators.\n   *\n   *   - `'default'` (the default), same as `black`.\n   *   - `'black'`, scroll indicator is black. This style is good against a light background.\n   *   - `'white'`, scroll indicator is white. This style is good against a dark background.\n   *\n   * @platform ios\n   */\n  indicatorStyle?: ?('default' | 'black' | 'white'),\n  /**\n   * When true, the ScrollView will try to lock to only vertical or horizontal\n   * scrolling while dragging.  The default value is false.\n   * @platform ios\n   */\n  directionalLockEnabled?: ?boolean,\n  /**\n   * When false, once tracking starts, won't try to drag if the touch moves.\n   * The default value is true.\n   * @platform ios\n   */\n  canCancelContentTouches?: ?boolean,\n  /**\n   * When set, the scroll view will adjust the scroll position so that the first child that is\n   * currently visible and at or beyond `minIndexForVisible` will not change position. This is\n   * useful for lists that are loading content in both directions, e.g. a chat thread, where new\n   * messages coming in might otherwise cause the scroll position to jump. A value of 0 is common,\n   * but other values such as 1 can be used to skip loading spinners or other content that should\n   * not maintain position.\n   *\n   * The optional `autoscrollToTopThreshold` can be used to make the content automatically scroll\n   * to the top after making the adjustment if the user was within the threshold of the top before\n   * the adjustment was made. This is also useful for chat-like applications where you want to see\n   * new messages scroll into place, but not if the user has scrolled up a ways and it would be\n   * disruptive to scroll a bunch.\n   *\n   * Caveat 1: Reordering elements in the scrollview with this enabled will probably cause\n   * jumpiness and jank. It can be fixed, but there are currently no plans to do so. For now,\n   * don't re-order the content of any ScrollViews or Lists that use this feature.\n   *\n   * Caveat 2: This simply uses `contentOffset` and `frame.origin` in native code to compute\n   * visibility. Occlusion, transforms, and other complexity won't be taken into account as to\n   * whether content is \"visible\" or not.\n   *\n   * @platform ios\n   */\n  maintainVisibleContentPosition?: ?$ReadOnly<{|\n    minIndexForVisible: number,\n    autoscrollToTopThreshold?: ?number,\n  |}>,\n  /**\n   * The maximum allowed zoom scale. The default value is 1.0.\n   * @platform ios\n   */\n  maximumZoomScale?: ?number,\n  /**\n   * The minimum allowed zoom scale. The default value is 1.0.\n   * @platform ios\n   */\n  minimumZoomScale?: ?number,\n  /**\n   * When true, ScrollView allows use of pinch gestures to zoom in and out.\n   * The default value is true.\n   * @platform ios\n   */\n  pinchGestureEnabled?: ?boolean,\n  /**\n   * This controls how often the scroll event will be fired while scrolling\n   * (as a time interval in ms). A lower number yields better accuracy for code\n   * that is tracking the scroll position, but can lead to scroll performance\n   * problems due to the volume of information being send over the bridge.\n   * You will not notice a difference between values set between 1-16 as the\n   * JS run loop is synced to the screen refresh rate. If you do not need precise\n   * scroll position tracking, set this value higher to limit the information\n   * being sent across the bridge. The default value is zero, which results in\n   * the scroll event being sent only once each time the view is scrolled.\n   * @platform ios\n   */\n  scrollEventThrottle?: ?number,\n  /**\n   * The amount by which the scroll view indicators are inset from the edges\n   * of the scroll view. This should normally be set to the same value as\n   * the `contentInset`. Defaults to `{0, 0, 0, 0}`.\n   * @platform ios\n   */\n  scrollIndicatorInsets?: ?EdgeInsetsProp,\n  /**\n   * When true, the scroll view scrolls to top when the status bar is tapped.\n   * The default value is true.\n   * @platform ios\n   */\n  scrollsToTop?: ?boolean,\n  /**\n   * When true, shows a horizontal scroll indicator.\n   * The default value is true.\n   */\n  showsHorizontalScrollIndicator?: ?boolean,\n  /**\n   * When `snapToInterval` is set, `snapToAlignment` will define the relationship\n   * of the snapping to the scroll view.\n   *\n   *   - `'start'` (the default) will align the snap at the left (horizontal) or top (vertical)\n   *   - `'center'` will align the snap in the center\n   *   - `'end'` will align the snap at the right (horizontal) or bottom (vertical)\n   *\n   * @platform ios\n   */\n  snapToAlignment?: ?('start' | 'center' | 'end'),\n  /**\n   * The current scale of the scroll view content. The default value is 1.0.\n   * @platform ios\n   */\n  zoomScale?: ?number,\n  /**\n   * This property specifies how the safe area insets are used to modify the\n   * content area of the scroll view. The default value of this property is\n   * \"never\". Available on iOS 11 and later.\n   * @platform ios\n   */\n  contentInsetAdjustmentBehavior?: ?(\n    | 'automatic'\n    | 'scrollableAxes'\n    | 'never'\n    | 'always'\n  ),\n  /**\n   * When true, ScrollView will emit updateChildFrames data in scroll events,\n   * otherwise will not compute or emit child frame data.  This only exists\n   * to support legacy issues, `onLayout` should be used instead to retrieve\n   * frame data.\n   * The default value is false.\n   * @platform ios\n   */\n  DEPRECATED_sendUpdatedChildFrames?: ?boolean,\n|}>;\n\ntype AndroidProps = $ReadOnly<{|\n  /**\n   * Enables nested scrolling for Android API level 21+.\n   * Nested scrolling is supported by default on iOS\n   * @platform android\n   */\n  nestedScrollEnabled?: ?boolean,\n  /**\n   * Sometimes a scrollview takes up more space than its content fills. When this is\n   * the case, this prop will fill the rest of the scrollview with a color to avoid setting\n   * a background and creating unnecessary overdraw. This is an advanced optimization\n   * that is not needed in the general case.\n   * @platform android\n   */\n  endFillColor?: ?ColorValue,\n  /**\n   * Tag used to log scroll performance on this scroll view. Will force\n   * momentum events to be turned on (see sendMomentumEvents). This doesn't do\n   * anything out of the box and you need to implement a custom native\n   * FpsListener for it to be useful.\n   * @platform android\n   */\n  scrollPerfTag?: ?string,\n  /**\n   * Used to override default value of overScroll mode.\n   *\n   * Possible values:\n   *\n   *  - `'auto'` - Default value, allow a user to over-scroll\n   *    this view only if the content is large enough to meaningfully scroll.\n   *  - `'always'` - Always allow a user to over-scroll this view.\n   *  - `'never'` - Never allow a user to over-scroll this view.\n   *\n   * @platform android\n   */\n  overScrollMode?: ?('auto' | 'always' | 'never'),\n|}>;\n\ntype VRProps = $ReadOnly<{|\n  /**\n   * Optionally an image can be used for the scroll bar thumb. This will\n   * override the color. While the image is loading or the image fails to\n   * load the color will be used instead. Use an alpha of 0 in the color\n   * to avoid seeing it while the image is loading.\n   *\n   * - `uri` - a string representing the resource identifier for the image, which\n   * should be either a local file path or the name of a static image resource\n   * - `number` - Opaque type returned by something like\n   * `import IMAGE from './image.jpg'`.\n   * @platform vr\n   */\n  scrollBarThumbImage?: ?($ReadOnly<{||}> | number), // Opaque type returned by import IMAGE from './image.jpg'\n|}>;\n\nexport type Props = $ReadOnly<{|\n  ...ViewProps,\n  ...TouchableProps,\n  ...IOSProps,\n  ...AndroidProps,\n  ...VRProps,\n\n  /**\n   * These styles will be applied to the scroll view content container which\n   * wraps all of the child views. Example:\n   *\n   * ```\n   * return (\n   *   <ScrollView contentContainerStyle={styles.contentContainer}>\n   *   </ScrollView>\n   * );\n   * ...\n   * const styles = StyleSheet.create({\n   *   contentContainer: {\n   *     paddingVertical: 20\n   *   }\n   * });\n   * ```\n   */\n  contentContainerStyle?: ?ViewStyleProp,\n  /**\n   * A floating-point number that determines how quickly the scroll view\n   * decelerates after the user lifts their finger. You may also use string\n   * shortcuts `\"normal\"` and `\"fast\"` which match the underlying iOS settings\n   * for `UIScrollViewDecelerationRateNormal` and\n   * `UIScrollViewDecelerationRateFast` respectively.\n   *\n   *   - `'normal'`: 0.998 on iOS, 0.985 on Android (the default)\n   *   - `'fast'`: 0.99 on iOS, 0.9 on Android\n   */\n  decelerationRate?: ?('fast' | 'normal' | number),\n  /**\n   * When true, the scroll view's children are arranged horizontally in a row\n   * instead of vertically in a column. The default value is false.\n   */\n  horizontal?: ?boolean,\n  /**\n   * If sticky headers should stick at the bottom instead of the top of the\n   * ScrollView. This is usually used with inverted ScrollViews.\n   */\n  invertStickyHeaders?: ?boolean,\n  /**\n   * Determines whether the keyboard gets dismissed in response to a drag.\n   *\n   * *Cross platform*\n   *\n   *   - `'none'` (the default), drags do not dismiss the keyboard.\n   *   - `'on-drag'`, the keyboard is dismissed when a drag begins.\n   *\n   * *iOS Only*\n   *\n   *   - `'interactive'`, the keyboard is dismissed interactively with the drag and moves in\n   *     synchrony with the touch; dragging upwards cancels the dismissal.\n   *     On android this is not supported and it will have the same behavior as 'none'.\n   */\n  keyboardDismissMode?: ?(\n    | 'none' // default\n    | 'on-drag' // cross-platform\n    | 'interactive'\n  ), // ios only\n  /**\n   * Determines when the keyboard should stay visible after a tap.\n   *\n   *   - `'never'` (the default), tapping outside of the focused text input when the keyboard\n   *     is up dismisses the keyboard. When this happens, children won't receive the tap.\n   *   - `'always'`, the keyboard will not dismiss automatically, and the scroll view will not\n   *     catch taps, but children of the scroll view can catch taps.\n   *   - `'handled'`, the keyboard will not dismiss automatically when the tap was handled by\n   *     a children, (or captured by an ancestor).\n   *   - `false`, deprecated, use 'never' instead\n   *   - `true`, deprecated, use 'always' instead\n   */\n  // $FlowFixMe(site=react_native_fb) Issues found when typing ScrollView\n  keyboardShouldPersistTaps?: ?('always' | 'never' | 'handled' | false | true),\n  /**\n   * Called when the momentum scroll starts (scroll which occurs as the ScrollView glides to a stop).\n   */\n  onMomentumScrollBegin?: ?Function,\n  /**\n   * Called when the momentum scroll ends (scroll which occurs as the ScrollView glides to a stop).\n   */\n  onMomentumScrollEnd?: ?Function,\n\n  /**\n   * Fires at most once per frame during scrolling. The frequency of the\n   * events can be controlled using the `scrollEventThrottle` prop.\n   */\n  onScroll?: ?Function,\n  /**\n   * Called when the user begins to drag the scroll view.\n   */\n  onScrollBeginDrag?: ?Function,\n  /**\n   * Called when the user stops dragging the scroll view and it either stops\n   * or begins to glide.\n   */\n  onScrollEndDrag?: ?Function,\n  /**\n   * Called when scrollable content view of the ScrollView changes.\n   *\n   * Handler function is passed the content width and content height as parameters:\n   * `(contentWidth, contentHeight)`\n   *\n   * It's implemented using onLayout handler attached to the content container\n   * which this ScrollView renders.\n   */\n  onContentSizeChange?: ?Function,\n  onKeyboardDidShow?: (event: PressEvent) => void,\n  /**\n   * When true, the scroll view stops on multiples of the scroll view's size\n   * when scrolling. This can be used for horizontal pagination. The default\n   * value is false.\n   *\n   * Note: Vertical pagination is not supported on Android.\n   */\n  pagingEnabled?: ?boolean,\n  /**\n   * When false, the view cannot be scrolled via touch interaction.\n   * The default value is true.\n   *\n   * Note that the view can always be scrolled by calling `scrollTo`.\n   */\n  scrollEnabled?: ?boolean,\n  /**\n   * When true, shows a vertical scroll indicator.\n   * The default value is true.\n   */\n  showsVerticalScrollIndicator?: ?boolean,\n  /**\n   * An array of child indices determining which children get docked to the\n   * top of the screen when scrolling. For example, passing\n   * `stickyHeaderIndices={[0]}` will cause the first child to be fixed to the\n   * top of the scroll view. This property is not supported in conjunction\n   * with `horizontal={true}`.\n   */\n  stickyHeaderIndices?: ?$ReadOnlyArray<number>,\n  /**\n   * When set, causes the scroll view to stop at multiples of the value of\n   * `snapToInterval`. This can be used for paginating through children\n   * that have lengths smaller than the scroll view. Typically used in\n   * combination with `snapToAlignment` and `decelerationRate=\"fast\"`.\n   *\n   * Overrides less configurable `pagingEnabled` prop.\n   */\n  snapToInterval?: ?number,\n  /**\n   * When set, causes the scroll view to stop at the defined offsets.\n   * This can be used for paginating through variously sized children\n   * that have lengths smaller than the scroll view. Typically used in\n   * combination with `decelerationRate=\"fast\"`.\n   *\n   * Overrides less configurable `pagingEnabled` and `snapToInterval` props.\n   */\n  snapToOffsets?: ?$ReadOnlyArray<number>,\n  /**\n   * Experimental: When true, offscreen child views (whose `overflow` value is\n   * `hidden`) are removed from their native backing superview when offscreen.\n   * This can improve scrolling performance on long lists. The default value is\n   * true.\n   */\n  removeClippedSubviews?: ?boolean,\n  /**\n   * A RefreshControl component, used to provide pull-to-refresh\n   * functionality for the ScrollView. Only works for vertical ScrollViews\n   * (`horizontal` prop must be `false`).\n   *\n   * See [RefreshControl](docs/refreshcontrol.html).\n   */\n  refreshControl?: ?React.Element<any>,\n  style?: ?ViewStyleProp,\n  children?: React.Node,\n|}>;\n\n/**\n * Component that wraps platform ScrollView while providing\n * integration with touch locking \"responder\" system.\n *\n * Keep in mind that ScrollViews must have a bounded height in order to work,\n * since they contain unbounded-height children into a bounded container (via\n * a scroll interaction). In order to bound the height of a ScrollView, either\n * set the height of the view directly (discouraged) or make sure all parent\n * views have bounded height. Forgetting to transfer `{flex: 1}` down the\n * view stack can lead to errors here, which the element inspector makes\n * easy to debug.\n *\n * Doesn't yet support other contained responders from blocking this scroll\n * view from becoming the responder.\n *\n *\n * `<ScrollView>` vs [`<FlatList>`](/react-native/docs/flatlist.html) - which one to use?\n *\n * `ScrollView` simply renders all its react child components at once. That\n * makes it very easy to understand and use.\n *\n * On the other hand, this has a performance downside. Imagine you have a very\n * long list of items you want to display, maybe several screens worth of\n * content. Creating JS components and native views for everything all at once,\n * much of which may not even be shown, will contribute to slow rendering and\n * increased memory usage.\n *\n * This is where `FlatList` comes into play. `FlatList` renders items lazily,\n * just when they are about to appear, and removes items that scroll way off\n * screen to save memory and processing time.\n *\n * `FlatList` is also handy if you want to render separators between your items,\n * multiple columns, infinite scroll loading, or any number of other features it\n * supports out of the box.\n */\nconst ScrollView = createReactClass({\n  displayName: 'ScrollView',\n  mixins: [ScrollResponder.Mixin],\n\n  _scrollAnimatedValue: (new AnimatedImplementation.Value(\n    0,\n  ): AnimatedImplementation.Value),\n  _scrollAnimatedValueAttachment: (null: ?{detach: () => void}),\n  _stickyHeaderRefs: (new Map(): Map<number, ScrollViewStickyHeader>),\n  _headerLayoutYs: (new Map(): Map<string, number>),\n  getInitialState: function() {\n    return {\n      ...this.scrollResponderMixinGetInitialState(),\n      layoutHeight: null,\n    };\n  },\n\n  UNSAFE_componentWillMount: function() {\n    this._scrollAnimatedValue = new AnimatedImplementation.Value(\n      this.props.contentOffset ? this.props.contentOffset.y : 0,\n    );\n    this._scrollAnimatedValue.setOffset(\n      this.props.contentInset ? this.props.contentInset.top : 0,\n    );\n    this._stickyHeaderRefs = new Map();\n    this._headerLayoutYs = new Map();\n  },\n\n  componentDidMount: function() {\n    this._updateAnimatedNodeAttachment();\n  },\n\n  componentDidUpdate: function() {\n    this._updateAnimatedNodeAttachment();\n  },\n\n  componentWillUnmount: function() {\n    if (this._scrollAnimatedValueAttachment) {\n      this._scrollAnimatedValueAttachment.detach();\n    }\n  },\n\n  setNativeProps: function(props: Object) {\n    this._scrollViewRef && this._scrollViewRef.setNativeProps(props);\n  },\n\n  /**\n   * Returns a reference to the underlying scroll responder, which supports\n   * operations like `scrollTo`. All ScrollView-like components should\n   * implement this method so that they can be composed while providing access\n   * to the underlying scroll responder's methods.\n   */\n  getScrollResponder: function(): ScrollView {\n    return this;\n  },\n\n  getScrollableNode: function(): any {\n    return ReactNative.findNodeHandle(this._scrollViewRef);\n  },\n\n  getInnerViewNode: function(): any {\n    return ReactNative.findNodeHandle(this._innerViewRef);\n  },\n\n  /**\n   * Scrolls to a given x, y offset, either immediately or with a smooth animation.\n   *\n   * Example:\n   *\n   * `scrollTo({x: 0, y: 0, animated: true})`\n   *\n   * Note: The weird function signature is due to the fact that, for historical reasons,\n   * the function also accepts separate arguments as an alternative to the options object.\n   * This is deprecated due to ambiguity (y before x), and SHOULD NOT BE USED.\n   */\n  scrollTo: function(\n    y?: number | {x?: number, y?: number, animated?: boolean},\n    x?: number,\n    animated?: boolean,\n  ) {\n    if (typeof y === 'number') {\n      console.warn(\n        '`scrollTo(y, x, animated)` is deprecated. Use `scrollTo({x: 5, y: 5, ' +\n          'animated: true})` instead.',\n      );\n    } else {\n      ({x, y, animated} = y || {});\n    }\n    this.getScrollResponder().scrollResponderScrollTo({\n      x: x || 0,\n      y: y || 0,\n      animated: animated !== false,\n    });\n  },\n\n  /**\n   * If this is a vertical ScrollView scrolls to the bottom.\n   * If this is a horizontal ScrollView scrolls to the right.\n   *\n   * Use `scrollToEnd({animated: true})` for smooth animated scrolling,\n   * `scrollToEnd({animated: false})` for immediate scrolling.\n   * If no options are passed, `animated` defaults to true.\n   */\n  scrollToEnd: function(options?: {animated?: boolean}) {\n    // Default to true\n    const animated = (options && options.animated) !== false;\n    this.getScrollResponder().scrollResponderScrollToEnd({\n      animated: animated,\n    });\n  },\n\n  /**\n   * Deprecated, use `scrollTo` instead.\n   */\n  scrollWithoutAnimationTo: function(y: number = 0, x: number = 0) {\n    console.warn(\n      '`scrollWithoutAnimationTo` is deprecated. Use `scrollTo` instead',\n    );\n    this.scrollTo({x, y, animated: false});\n  },\n\n  /**\n   * Displays the scroll indicators momentarily.\n   *\n   * @platform ios\n   */\n  flashScrollIndicators: function() {\n    this.getScrollResponder().scrollResponderFlashScrollIndicators();\n  },\n\n  _getKeyForIndex: function(index, childArray) {\n    // $FlowFixMe Invalid prop usage\n    const child = childArray[index];\n    return child && child.key;\n  },\n\n  _updateAnimatedNodeAttachment: function() {\n    if (this._scrollAnimatedValueAttachment) {\n      this._scrollAnimatedValueAttachment.detach();\n    }\n    if (\n      this.props.stickyHeaderIndices &&\n      this.props.stickyHeaderIndices.length > 0\n    ) {\n      this._scrollAnimatedValueAttachment = AnimatedImplementation.attachNativeEvent(\n        this._scrollViewRef,\n        'onScroll',\n        [{nativeEvent: {contentOffset: {y: this._scrollAnimatedValue}}}],\n      );\n    }\n  },\n\n  _setStickyHeaderRef: function(key, ref) {\n    if (ref) {\n      this._stickyHeaderRefs.set(key, ref);\n    } else {\n      this._stickyHeaderRefs.delete(key);\n    }\n  },\n\n  _onStickyHeaderLayout: function(index, event, key) {\n    if (!this.props.stickyHeaderIndices) {\n      return;\n    }\n    const childArray = React.Children.toArray(this.props.children);\n    if (key !== this._getKeyForIndex(index, childArray)) {\n      // ignore stale layout update\n      return;\n    }\n\n    const layoutY = event.nativeEvent.layout.y;\n    this._headerLayoutYs.set(key, layoutY);\n\n    const indexOfIndex = this.props.stickyHeaderIndices.indexOf(index);\n    const previousHeaderIndex = this.props.stickyHeaderIndices[\n      indexOfIndex - 1\n    ];\n    if (previousHeaderIndex != null) {\n      const previousHeader = this._stickyHeaderRefs.get(\n        this._getKeyForIndex(previousHeaderIndex, childArray),\n      );\n      previousHeader && previousHeader.setNextHeaderY(layoutY);\n    }\n  },\n\n  _handleScroll: function(e: Object) {\n    if (__DEV__) {\n      if (\n        this.props.onScroll &&\n        this.props.scrollEventThrottle == null &&\n        Platform.OS === 'ios'\n      ) {\n        console.log(\n          'You specified `onScroll` on a <ScrollView> but not ' +\n            '`scrollEventThrottle`. You will only receive one event. ' +\n            'Using `16` you get all the events but be aware that it may ' +\n            \"cause frame drops, use a bigger number if you don't need as \" +\n            'much precision.',\n        );\n      }\n    }\n    if (Platform.OS === 'android') {\n      if (\n        this.props.keyboardDismissMode === 'on-drag' &&\n        this.state.isTouching\n      ) {\n        dismissKeyboard();\n      }\n    }\n    this.scrollResponderHandleScroll(e);\n  },\n\n  _handleLayout: function(e: Object) {\n    if (this.props.invertStickyHeaders) {\n      this.setState({layoutHeight: e.nativeEvent.layout.height});\n    }\n    if (this.props.onLayout) {\n      this.props.onLayout(e);\n    }\n  },\n\n  _handleContentOnLayout: function(e: Object) {\n    const {width, height} = e.nativeEvent.layout;\n    this.props.onContentSizeChange &&\n      this.props.onContentSizeChange(width, height);\n  },\n\n  _scrollViewRef: (null: ?ScrollView),\n  _setScrollViewRef: function(ref: ?ScrollView) {\n    this._scrollViewRef = ref;\n  },\n\n  _innerViewRef: (null: ?NativeMethodsMixinType),\n  _setInnerViewRef: function(ref: ?NativeMethodsMixinType) {\n    this._innerViewRef = ref;\n  },\n\n  render: function() {\n    let ScrollViewClass;\n    let ScrollContentContainerViewClass;\n    if (Platform.OS === 'android') {\n      if (this.props.horizontal) {\n        ScrollViewClass = AndroidHorizontalScrollView;\n        ScrollContentContainerViewClass = AndroidHorizontalScrollContentView;\n      } else {\n        ScrollViewClass = AndroidScrollView;\n        ScrollContentContainerViewClass = View;\n      }\n    } else {\n      ScrollViewClass = RCTScrollView;\n      ScrollContentContainerViewClass = RCTScrollContentView;\n    }\n\n    invariant(\n      ScrollViewClass !== undefined,\n      'ScrollViewClass must not be undefined',\n    );\n\n    invariant(\n      ScrollContentContainerViewClass !== undefined,\n      'ScrollContentContainerViewClass must not be undefined',\n    );\n\n    const contentContainerStyle = [\n      this.props.horizontal && styles.contentContainerHorizontal,\n      this.props.contentContainerStyle,\n    ];\n    if (__DEV__ && this.props.style) {\n      const style = flattenStyle(this.props.style);\n      const childLayoutProps = ['alignItems', 'justifyContent'].filter(\n        prop => style && style[prop] !== undefined,\n      );\n      invariant(\n        childLayoutProps.length === 0,\n        'ScrollView child layout (' +\n          JSON.stringify(childLayoutProps) +\n          ') must be applied through the contentContainerStyle prop.',\n      );\n    }\n\n    let contentSizeChangeProps = {};\n    if (this.props.onContentSizeChange) {\n      contentSizeChangeProps = {\n        onLayout: this._handleContentOnLayout,\n      };\n    }\n\n    const {stickyHeaderIndices} = this.props;\n    const hasStickyHeaders =\n      stickyHeaderIndices && stickyHeaderIndices.length > 0;\n    const childArray =\n      hasStickyHeaders && React.Children.toArray(this.props.children);\n    const children = hasStickyHeaders\n      ? // $FlowFixMe Invalid prop usage\n        childArray.map((child, index) => {\n          const indexOfIndex = child ? stickyHeaderIndices.indexOf(index) : -1;\n          if (indexOfIndex > -1) {\n            const key = child.key;\n            const nextIndex = stickyHeaderIndices[indexOfIndex + 1];\n            return (\n              <ScrollViewStickyHeader\n                key={key}\n                ref={ref => this._setStickyHeaderRef(key, ref)}\n                nextHeaderLayoutY={this._headerLayoutYs.get(\n                  this._getKeyForIndex(nextIndex, childArray),\n                )}\n                onLayout={event =>\n                  this._onStickyHeaderLayout(index, event, key)\n                }\n                scrollAnimatedValue={this._scrollAnimatedValue}\n                inverted={this.props.invertStickyHeaders}\n                scrollViewHeight={this.state.layoutHeight}>\n                {child}\n              </ScrollViewStickyHeader>\n            );\n          } else {\n            return child;\n          }\n        })\n      : this.props.children;\n    const contentContainer = (\n      <ScrollContentContainerViewClass\n        {...contentSizeChangeProps}\n        // $FlowFixMe Invalid prop usage\n        ref={this._setInnerViewRef}\n        style={contentContainerStyle}\n        removeClippedSubviews={\n          // Subview clipping causes issues with sticky headers on Android and\n          // would be hard to fix properly in a performant way.\n          Platform.OS === 'android' && hasStickyHeaders\n            ? false\n            : this.props.removeClippedSubviews\n        }\n        collapsable={false}>\n        {children}\n      </ScrollContentContainerViewClass>\n    );\n\n    const alwaysBounceHorizontal =\n      this.props.alwaysBounceHorizontal !== undefined\n        ? this.props.alwaysBounceHorizontal\n        : this.props.horizontal;\n\n    const alwaysBounceVertical =\n      this.props.alwaysBounceVertical !== undefined\n        ? this.props.alwaysBounceVertical\n        : !this.props.horizontal;\n\n    const DEPRECATED_sendUpdatedChildFrames = !!this.props\n      .DEPRECATED_sendUpdatedChildFrames;\n\n    const baseStyle = this.props.horizontal\n      ? styles.baseHorizontal\n      : styles.baseVertical;\n    const props = {\n      ...this.props,\n      alwaysBounceHorizontal,\n      alwaysBounceVertical,\n      style: ([baseStyle, this.props.style]: ?Array<any>),\n      // Override the onContentSizeChange from props, since this event can\n      // bubble up from TextInputs\n      onContentSizeChange: null,\n      onLayout: this._handleLayout,\n      onMomentumScrollBegin: this.scrollResponderHandleMomentumScrollBegin,\n      onMomentumScrollEnd: this.scrollResponderHandleMomentumScrollEnd,\n      onResponderGrant: this.scrollResponderHandleResponderGrant,\n      onResponderReject: this.scrollResponderHandleResponderReject,\n      onResponderRelease: this.scrollResponderHandleResponderRelease,\n      // $FlowFixMe\n      onResponderTerminate: this.scrollResponderHandleTerminate,\n      onResponderTerminationRequest: this\n        .scrollResponderHandleTerminationRequest,\n      onScroll: this._handleScroll,\n      onScrollBeginDrag: this.scrollResponderHandleScrollBeginDrag,\n      onScrollEndDrag: this.scrollResponderHandleScrollEndDrag,\n      onScrollShouldSetResponder: this\n        .scrollResponderHandleScrollShouldSetResponder,\n      onStartShouldSetResponder: this\n        .scrollResponderHandleStartShouldSetResponder,\n      onStartShouldSetResponderCapture: this\n        .scrollResponderHandleStartShouldSetResponderCapture,\n      onTouchEnd: this.scrollResponderHandleTouchEnd,\n      onTouchMove: this.scrollResponderHandleTouchMove,\n      onTouchStart: this.scrollResponderHandleTouchStart,\n      onTouchCancel: this.scrollResponderHandleTouchCancel,\n      scrollBarThumbImage: resolveAssetSource(this.props.scrollBarThumbImage),\n      scrollEventThrottle: hasStickyHeaders\n        ? 1\n        : this.props.scrollEventThrottle,\n      sendMomentumEvents:\n        this.props.onMomentumScrollBegin || this.props.onMomentumScrollEnd\n          ? true\n          : false,\n      DEPRECATED_sendUpdatedChildFrames,\n      // pagingEnabled is overridden by snapToInterval / snapToOffsets\n      pagingEnabled: Platform.select({\n        // on iOS, pagingEnabled must be set to false to have snapToInterval / snapToOffsets work\n        ios:\n          this.props.pagingEnabled &&\n          this.props.snapToInterval == null &&\n          this.props.snapToOffsets == null,\n        // on Android, pagingEnabled must be set to true to have snapToInterval / snapToOffsets work\n        android:\n          this.props.pagingEnabled ||\n          this.props.snapToInterval != null ||\n          this.props.snapToOffsets != null,\n      }),\n    };\n\n    const {decelerationRate} = this.props;\n    if (decelerationRate != null) {\n      props.decelerationRate = processDecelerationRate(decelerationRate);\n    }\n\n    const refreshControl = this.props.refreshControl;\n\n    if (refreshControl) {\n      if (Platform.OS === 'ios') {\n        // On iOS the RefreshControl is a child of the ScrollView.\n        // tvOS lacks native support for RefreshControl, so don't include it in that case\n        return (\n          <ScrollViewClass {...props} ref={this._setScrollViewRef}>\n            {Platform.isTV ? null : refreshControl}\n            {contentContainer}\n          </ScrollViewClass>\n        );\n      } else if (Platform.OS === 'android') {\n        // On Android wrap the ScrollView with a AndroidSwipeRefreshLayout.\n        // Since the ScrollView is wrapped add the style props to the\n        // AndroidSwipeRefreshLayout and use flex: 1 for the ScrollView.\n        // Note: we should only apply props.style on the wrapper\n        // however, the ScrollView still needs the baseStyle to be scrollable\n\n        return React.cloneElement(\n          refreshControl,\n          {style: props.style},\n          <ScrollViewClass\n            {...props}\n            style={baseStyle}\n            ref={this._setScrollViewRef}>\n            {contentContainer}\n          </ScrollViewClass>,\n        );\n      }\n    }\n    return (\n      <ScrollViewClass {...props} ref={this._setScrollViewRef}>\n        {contentContainer}\n      </ScrollViewClass>\n    );\n  },\n});\n\nconst TypedScrollView = ((ScrollView: any): Class<\n  InternalScrollViewType<Props>,\n>);\n\nconst styles = StyleSheet.create({\n  baseVertical: {\n    flexGrow: 1,\n    flexShrink: 1,\n    flexDirection: 'column',\n    overflow: 'scroll',\n  },\n  baseHorizontal: {\n    flexGrow: 1,\n    flexShrink: 1,\n    flexDirection: 'row',\n    overflow: 'scroll',\n  },\n  contentContainerHorizontal: {\n    flexDirection: 'row',\n  },\n});\n\nmodule.exports = TypedScrollView;\n"]}]}