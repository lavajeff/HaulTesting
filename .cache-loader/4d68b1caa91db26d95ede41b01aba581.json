{"remainingRequest":"/Users/jeffrey/HaulTesting/node_modules/thread-loader/dist/cjs.js??ref--5-1!/Users/jeffrey/HaulTesting/node_modules/babel-loader/lib/index.js??ref--5-2!/Users/jeffrey/HaulTesting/node_modules/react-native/Libraries/Components/ScrollView/ScrollViewStickyHeader.js","dependencies":[{"path":"/Users/jeffrey/HaulTesting/node_modules/react-native/Libraries/Components/ScrollView/ScrollViewStickyHeader.js","mtime":1539700108130},{"path":"/Users/jeffrey/HaulTesting/node_modules/cache-loader/dist/cjs.js","mtime":1539652983212},{"path":"/Users/jeffrey/HaulTesting/node_modules/thread-loader/dist/cjs.js","mtime":1539652983315},{"path":"/Users/jeffrey/HaulTesting/node_modules/babel-loader/lib/index.js","mtime":1539615827828}],"contextDependencies":[],"result":["'use strict';var _interopRequireDefault=require(\"@babel/runtime/helpers/interopRequireDefault\");var _classCallCheck2=_interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));var _createClass2=_interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));var _possibleConstructorReturn2=_interopRequireDefault(require(\"@babel/runtime/helpers/possibleConstructorReturn\"));var _getPrototypeOf3=_interopRequireDefault(require(\"@babel/runtime/helpers/getPrototypeOf\"));var _inherits2=_interopRequireDefault(require(\"@babel/runtime/helpers/inherits\"));var _jsxFileName=\"/Users/jeffrey/HaulTesting/node_modules/react-native/Libraries/Components/ScrollView/ScrollViewStickyHeader.js\";(function(){var enterModule=require('react-hot-loader').enterModule;enterModule&&enterModule(module);})();var AnimatedImplementation=require('AnimatedImplementation');var React=require('React');var StyleSheet=require('StyleSheet');var View=require('View');var AnimatedView=AnimatedImplementation.createAnimatedComponent(View);var ScrollViewStickyHeader=function(_React$Component){(0,_inherits2.default)(ScrollViewStickyHeader,_React$Component);function ScrollViewStickyHeader(){var _getPrototypeOf2;var _this;(0,_classCallCheck2.default)(this,ScrollViewStickyHeader);for(var _len=arguments.length,args=new Array(_len),_key=0;_key<_len;_key++){args[_key]=arguments[_key];}_this=(0,_possibleConstructorReturn2.default)(this,(_getPrototypeOf2=(0,_getPrototypeOf3.default)(ScrollViewStickyHeader)).call.apply(_getPrototypeOf2,[this].concat(args)));_this.state={measured:false,layoutY:0,layoutHeight:0,nextHeaderLayoutY:_this.props.nextHeaderLayoutY};_this._onLayout=function(event){_this.setState({measured:true,layoutY:event.nativeEvent.layout.y,layoutHeight:event.nativeEvent.layout.height});_this.props.onLayout(event);var child=React.Children.only(_this.props.children);if(child.props.onLayout){child.props.onLayout(event);}};return _this;}(0,_createClass2.default)(ScrollViewStickyHeader,[{key:\"setNextHeaderY\",value:function setNextHeaderY(y){this.setState({nextHeaderLayoutY:y});}},{key:\"render\",value:function render(){var _this$props=this.props,inverted=_this$props.inverted,scrollViewHeight=_this$props.scrollViewHeight;var _this$state=this.state,measured=_this$state.measured,layoutHeight=_this$state.layoutHeight,layoutY=_this$state.layoutY,nextHeaderLayoutY=_this$state.nextHeaderLayoutY;var inputRange=[-1,0];var outputRange=[0,0];if(measured){if(inverted){if(scrollViewHeight!=null){var stickStartPoint=layoutY+layoutHeight-scrollViewHeight;if(stickStartPoint>0){inputRange.push(stickStartPoint);outputRange.push(0);inputRange.push(stickStartPoint+1);outputRange.push(1);var collisionPoint=(nextHeaderLayoutY||0)-layoutHeight-scrollViewHeight;if(collisionPoint>stickStartPoint){inputRange.push(collisionPoint,collisionPoint+1);outputRange.push(collisionPoint-stickStartPoint,collisionPoint-stickStartPoint);}}}}else{inputRange.push(layoutY);outputRange.push(0);var _collisionPoint=(nextHeaderLayoutY||0)-layoutHeight;if(_collisionPoint>=layoutY){inputRange.push(_collisionPoint,_collisionPoint+1);outputRange.push(_collisionPoint-layoutY,_collisionPoint-layoutY);}else{inputRange.push(layoutY+1);outputRange.push(1);}}}var translateY=this.props.scrollAnimatedValue.interpolate({inputRange:inputRange,outputRange:outputRange});var child=React.Children.only(this.props.children);return React.createElement(AnimatedView,{collapsable:false,onLayout:this._onLayout,style:[child.props.style,styles.header,{transform:[{translateY:translateY}]}],__source:{fileName:_jsxFileName,lineNumber:141}},React.cloneElement(child,{style:styles.fill,onLayout:undefined}));}},{key:\"__reactstandin__regenerateByEval\",value:function __reactstandin__regenerateByEval(key,code){this[key]=eval(code);}}]);return ScrollViewStickyHeader;}(React.Component);var styles=StyleSheet.create({header:{zIndex:10},fill:{flex:1}});module.exports=ScrollViewStickyHeader;;(function(){var reactHotLoader=require('react-hot-loader').default;var leaveModule=require('react-hot-loader').leaveModule;if(!reactHotLoader){return;}reactHotLoader.register(AnimatedView,\"AnimatedView\",\"/Users/jeffrey/HaulTesting/node_modules/react-native/Libraries/Components/ScrollView/ScrollViewStickyHeader.js\");reactHotLoader.register(ScrollViewStickyHeader,\"ScrollViewStickyHeader\",\"/Users/jeffrey/HaulTesting/node_modules/react-native/Libraries/Components/ScrollView/ScrollViewStickyHeader.js\");reactHotLoader.register(styles,\"styles\",\"/Users/jeffrey/HaulTesting/node_modules/react-native/Libraries/Components/ScrollView/ScrollViewStickyHeader.js\");leaveModule(module);})();;",{"version":3,"sources":["/Users/jeffrey/HaulTesting/node_modules/react-native/Libraries/Components/ScrollView/ScrollViewStickyHeader.js"],"names":["AnimatedImplementation","require","React","StyleSheet","View","AnimatedView","createAnimatedComponent","ScrollViewStickyHeader","state","measured","layoutY","layoutHeight","nextHeaderLayoutY","props","_onLayout","event","setState","nativeEvent","layout","y","height","onLayout","child","Children","only","children","inverted","scrollViewHeight","inputRange","outputRange","stickStartPoint","push","collisionPoint","translateY","scrollAnimatedValue","interpolate","style","styles","header","transform","cloneElement","fill","undefined","Component","create","zIndex","flex","module","exports"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n * @format\n */\n'use strict';\n\nconst AnimatedImplementation = require('AnimatedImplementation');\nconst React = require('React');\nconst StyleSheet = require('StyleSheet');\nconst View = require('View');\n\nimport type {LayoutEvent} from 'CoreEventTypes';\n\nconst AnimatedView = AnimatedImplementation.createAnimatedComponent(View);\n\ntype Props = {\n  children?: React.Element<any>,\n  nextHeaderLayoutY: ?number,\n  onLayout: (event: LayoutEvent) => void,\n  scrollAnimatedValue: AnimatedImplementation.Value,\n  // Will cause sticky headers to stick at the bottom of the ScrollView instead\n  // of the top.\n  inverted: ?boolean,\n  // The height of the parent ScrollView. Currently only set when inverted.\n  scrollViewHeight: ?number,\n};\n\ntype State = {\n  measured: boolean,\n  layoutY: number,\n  layoutHeight: number,\n  nextHeaderLayoutY: ?number,\n};\n\nclass ScrollViewStickyHeader extends React.Component<Props, State> {\n  state = {\n    measured: false,\n    layoutY: 0,\n    layoutHeight: 0,\n    nextHeaderLayoutY: this.props.nextHeaderLayoutY,\n  };\n\n  setNextHeaderY(y: number) {\n    this.setState({nextHeaderLayoutY: y});\n  }\n\n  _onLayout = event => {\n    this.setState({\n      measured: true,\n      layoutY: event.nativeEvent.layout.y,\n      layoutHeight: event.nativeEvent.layout.height,\n    });\n\n    this.props.onLayout(event);\n    const child = React.Children.only(this.props.children);\n    if (child.props.onLayout) {\n      child.props.onLayout(event);\n    }\n  };\n\n  render() {\n    const {inverted, scrollViewHeight} = this.props;\n    const {measured, layoutHeight, layoutY, nextHeaderLayoutY} = this.state;\n    const inputRange: Array<number> = [-1, 0];\n    const outputRange: Array<number> = [0, 0];\n\n    if (measured) {\n      if (inverted) {\n        // The interpolation looks like:\n        // - Negative scroll: no translation\n        // - `stickStartPoint` is the point at which the header will start sticking.\n        //   It is calculated using the ScrollView viewport height so it is a the bottom.\n        // - Headers that are in the initial viewport will never stick, `stickStartPoint`\n        //   will be negative.\n        // - From 0 to `stickStartPoint` no translation. This will cause the header\n        //   to scroll normally until it reaches the top of the scroll view.\n        // - From `stickStartPoint` to when the next header y hits the bottom edge of the header: translate\n        //   equally to scroll. This will cause the header to stay at the top of the scroll view.\n        // - Past the collision with the next header y: no more translation. This will cause the\n        //   header to continue scrolling up and make room for the next sticky header.\n        //   In the case that there is no next header just translate equally to\n        //   scroll indefinitely.\n        if (scrollViewHeight != null) {\n          const stickStartPoint = layoutY + layoutHeight - scrollViewHeight;\n          if (stickStartPoint > 0) {\n            inputRange.push(stickStartPoint);\n            outputRange.push(0);\n            inputRange.push(stickStartPoint + 1);\n            outputRange.push(1);\n            // If the next sticky header has not loaded yet (probably windowing) or is the last\n            // we can just keep it sticked forever.\n            const collisionPoint =\n              (nextHeaderLayoutY || 0) - layoutHeight - scrollViewHeight;\n            if (collisionPoint > stickStartPoint) {\n              inputRange.push(collisionPoint, collisionPoint + 1);\n              outputRange.push(\n                collisionPoint - stickStartPoint,\n                collisionPoint - stickStartPoint,\n              );\n            }\n          }\n        }\n      } else {\n        // The interpolation looks like:\n        // - Negative scroll: no translation\n        // - From 0 to the y of the header: no translation. This will cause the header\n        //   to scroll normally until it reaches the top of the scroll view.\n        // - From header y to when the next header y hits the bottom edge of the header: translate\n        //   equally to scroll. This will cause the header to stay at the top of the scroll view.\n        // - Past the collision with the next header y: no more translation. This will cause the\n        //   header to continue scrolling up and make room for the next sticky header.\n        //   In the case that there is no next header just translate equally to\n        //   scroll indefinitely.\n        inputRange.push(layoutY);\n        outputRange.push(0);\n        // If the next sticky header has not loaded yet (probably windowing) or is the last\n        // we can just keep it sticked forever.\n        const collisionPoint = (nextHeaderLayoutY || 0) - layoutHeight;\n        if (collisionPoint >= layoutY) {\n          inputRange.push(collisionPoint, collisionPoint + 1);\n          outputRange.push(collisionPoint - layoutY, collisionPoint - layoutY);\n        } else {\n          inputRange.push(layoutY + 1);\n          outputRange.push(1);\n        }\n      }\n    }\n\n    const translateY = this.props.scrollAnimatedValue.interpolate({\n      inputRange,\n      outputRange,\n    });\n    const child = React.Children.only(this.props.children);\n\n    return (\n      <AnimatedView\n        collapsable={false}\n        onLayout={this._onLayout}\n        style={[child.props.style, styles.header, {transform: [{translateY}]}]}>\n        {React.cloneElement(child, {\n          style: styles.fill, // We transfer the child style to the wrapper.\n          onLayout: undefined, // we call this manually through our this._onLayout\n        })}\n      </AnimatedView>\n    );\n  }\n}\n\nconst styles = StyleSheet.create({\n  header: {\n    zIndex: 10,\n  },\n  fill: {\n    flex: 1,\n  },\n});\n\nmodule.exports = ScrollViewStickyHeader;\n"]}]}