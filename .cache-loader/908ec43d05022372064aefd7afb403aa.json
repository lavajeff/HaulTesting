{"remainingRequest":"/Users/jeffrey/HaulTesting/node_modules/thread-loader/dist/cjs.js??ref--5-1!/Users/jeffrey/HaulTesting/node_modules/babel-loader/lib/index.js??ref--5-2!/Users/jeffrey/HaulTesting/node_modules/react-native/Libraries/Lists/VirtualizeUtils.js","dependencies":[{"path":"/Users/jeffrey/HaulTesting/node_modules/react-native/Libraries/Lists/VirtualizeUtils.js","mtime":1539700108130},{"path":"/Users/jeffrey/HaulTesting/node_modules/cache-loader/dist/cjs.js","mtime":1539652983212},{"path":"/Users/jeffrey/HaulTesting/node_modules/thread-loader/dist/cjs.js","mtime":1539652983315},{"path":"/Users/jeffrey/HaulTesting/node_modules/babel-loader/lib/index.js","mtime":1539615827828}],"contextDependencies":[],"result":["'use strict';var _interopRequireDefault=require(\"@babel/runtime/helpers/interopRequireDefault\");var _slicedToArray2=_interopRequireDefault(require(\"@babel/runtime/helpers/slicedToArray\"));(function(){var enterModule=require('react-hot-loader').enterModule;enterModule&&enterModule(module);})();var invariant=require('fbjs/lib/invariant');function elementsThatOverlapOffsets(offsets,itemCount,getFrameMetrics){var out=[];var outLength=0;for(var ii=0;ii<itemCount;ii++){var frame=getFrameMetrics(ii);var trailingOffset=frame.offset+frame.length;for(var kk=0;kk<offsets.length;kk++){if(out[kk]==null&&trailingOffset>=offsets[kk]){out[kk]=ii;outLength++;if(kk===offsets.length-1){invariant(outLength===offsets.length,'bad offsets input, should be in increasing order: %s',JSON.stringify(offsets));return out;}}}}return out;}function newRangeCount(prev,next){return next.last-next.first+1-Math.max(0,1+Math.min(next.last,prev.last)-Math.max(next.first,prev.first));}function computeWindowedRenderLimits(props,prev,getFrameMetricsApprox,scrollMetrics){var data=props.data,getItemCount=props.getItemCount,maxToRenderPerBatch=props.maxToRenderPerBatch,windowSize=props.windowSize;var itemCount=getItemCount(data);if(itemCount===0){return prev;}var offset=scrollMetrics.offset,velocity=scrollMetrics.velocity,visibleLength=scrollMetrics.visibleLength;var visibleBegin=Math.max(0,offset);var visibleEnd=visibleBegin+visibleLength;var overscanLength=(windowSize-1)*visibleLength;var leadFactor=0.5;var fillPreference=velocity>1?'after':velocity<-1?'before':'none';var overscanBegin=Math.max(0,visibleBegin-(1-leadFactor)*overscanLength);var overscanEnd=Math.max(0,visibleEnd+leadFactor*overscanLength);var lastItemOffset=getFrameMetricsApprox(itemCount-1).offset;if(lastItemOffset<overscanBegin){return{first:Math.max(0,itemCount-1-maxToRenderPerBatch),last:itemCount-1};}var _elementsThatOverlapO=elementsThatOverlapOffsets([overscanBegin,visibleBegin,visibleEnd,overscanEnd],props.getItemCount(props.data),getFrameMetricsApprox),_elementsThatOverlapO2=(0,_slicedToArray2.default)(_elementsThatOverlapO,4),overscanFirst=_elementsThatOverlapO2[0],first=_elementsThatOverlapO2[1],last=_elementsThatOverlapO2[2],overscanLast=_elementsThatOverlapO2[3];overscanFirst=overscanFirst==null?0:overscanFirst;first=first==null?Math.max(0,overscanFirst):first;overscanLast=overscanLast==null?itemCount-1:overscanLast;last=last==null?Math.min(overscanLast,first+maxToRenderPerBatch-1):last;var visible={first:first,last:last};var newCellCount=newRangeCount(prev,visible);while(true){if(first<=overscanFirst&&last>=overscanLast){break;}var maxNewCells=newCellCount>=maxToRenderPerBatch;var firstWillAddMore=first<=prev.first||first>prev.last;var firstShouldIncrement=first>overscanFirst&&(!maxNewCells||!firstWillAddMore);var lastWillAddMore=last>=prev.last||last<prev.first;var lastShouldIncrement=last<overscanLast&&(!maxNewCells||!lastWillAddMore);if(maxNewCells&&!firstShouldIncrement&&!lastShouldIncrement){break;}if(firstShouldIncrement&&!(fillPreference==='after'&&lastShouldIncrement&&lastWillAddMore)){if(firstWillAddMore){newCellCount++;}first--;}if(lastShouldIncrement&&!(fillPreference==='before'&&firstShouldIncrement&&firstWillAddMore)){if(lastWillAddMore){newCellCount++;}last++;}}if(!(last>=first&&first>=0&&last<itemCount&&first>=overscanFirst&&last<=overscanLast&&first<=visible.first&&last>=visible.last)){throw new Error('Bad window calculation '+JSON.stringify({first:first,last:last,itemCount:itemCount,overscanFirst:overscanFirst,overscanLast:overscanLast,visible:visible}));}return{first:first,last:last};}var VirtualizeUtils={computeWindowedRenderLimits:computeWindowedRenderLimits,elementsThatOverlapOffsets:elementsThatOverlapOffsets,newRangeCount:newRangeCount};module.exports=VirtualizeUtils;;(function(){var reactHotLoader=require('react-hot-loader').default;var leaveModule=require('react-hot-loader').leaveModule;if(!reactHotLoader){return;}reactHotLoader.register(elementsThatOverlapOffsets,\"elementsThatOverlapOffsets\",\"/Users/jeffrey/HaulTesting/node_modules/react-native/Libraries/Lists/VirtualizeUtils.js\");reactHotLoader.register(newRangeCount,\"newRangeCount\",\"/Users/jeffrey/HaulTesting/node_modules/react-native/Libraries/Lists/VirtualizeUtils.js\");reactHotLoader.register(computeWindowedRenderLimits,\"computeWindowedRenderLimits\",\"/Users/jeffrey/HaulTesting/node_modules/react-native/Libraries/Lists/VirtualizeUtils.js\");reactHotLoader.register(VirtualizeUtils,\"VirtualizeUtils\",\"/Users/jeffrey/HaulTesting/node_modules/react-native/Libraries/Lists/VirtualizeUtils.js\");leaveModule(module);})();;",{"version":3,"sources":["/Users/jeffrey/HaulTesting/node_modules/react-native/Libraries/Lists/VirtualizeUtils.js"],"names":["invariant","require","elementsThatOverlapOffsets","offsets","itemCount","getFrameMetrics","out","outLength","ii","frame","trailingOffset","offset","length","kk","JSON","stringify","newRangeCount","prev","next","last","first","Math","max","min","computeWindowedRenderLimits","props","getFrameMetricsApprox","scrollMetrics","data","getItemCount","maxToRenderPerBatch","windowSize","velocity","visibleLength","visibleBegin","visibleEnd","overscanLength","leadFactor","fillPreference","overscanBegin","overscanEnd","lastItemOffset","overscanFirst","overscanLast","visible","newCellCount","maxNewCells","firstWillAddMore","firstShouldIncrement","lastWillAddMore","lastShouldIncrement","Error","VirtualizeUtils","module","exports"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n * @format\n */\n'use strict';\n\nconst invariant = require('fbjs/lib/invariant');\n\n/**\n * Used to find the indices of the frames that overlap the given offsets. Useful for finding the\n * items that bound different windows of content, such as the visible area or the buffered overscan\n * area.\n */\nfunction elementsThatOverlapOffsets(\n  offsets: Array<number>,\n  itemCount: number,\n  getFrameMetrics: (index: number) => {length: number, offset: number},\n): Array<number> {\n  const out = [];\n  let outLength = 0;\n  for (let ii = 0; ii < itemCount; ii++) {\n    const frame = getFrameMetrics(ii);\n    const trailingOffset = frame.offset + frame.length;\n    for (let kk = 0; kk < offsets.length; kk++) {\n      if (out[kk] == null && trailingOffset >= offsets[kk]) {\n        out[kk] = ii;\n        outLength++;\n        if (kk === offsets.length - 1) {\n          invariant(\n            outLength === offsets.length,\n            'bad offsets input, should be in increasing order: %s',\n            JSON.stringify(offsets),\n          );\n          return out;\n        }\n      }\n    }\n  }\n  return out;\n}\n\n/**\n * Computes the number of elements in the `next` range that are new compared to the `prev` range.\n * Handy for calculating how many new items will be rendered when the render window changes so we\n * can restrict the number of new items render at once so that content can appear on the screen\n * faster.\n */\nfunction newRangeCount(\n  prev: {first: number, last: number},\n  next: {first: number, last: number},\n): number {\n  return (\n    next.last -\n    next.first +\n    1 -\n    Math.max(\n      0,\n      1 + Math.min(next.last, prev.last) - Math.max(next.first, prev.first),\n    )\n  );\n}\n\n/**\n * Custom logic for determining which items should be rendered given the current frame and scroll\n * metrics, as well as the previous render state. The algorithm may evolve over time, but generally\n * prioritizes the visible area first, then expands that with overscan regions ahead and behind,\n * biased in the direction of scroll.\n */\nfunction computeWindowedRenderLimits(\n  props: {\n    data: any,\n    getItemCount: (data: any) => number,\n    maxToRenderPerBatch: number,\n    windowSize: number,\n  },\n  prev: {first: number, last: number},\n  getFrameMetricsApprox: (index: number) => {length: number, offset: number},\n  scrollMetrics: {\n    dt: number,\n    offset: number,\n    velocity: number,\n    visibleLength: number,\n  },\n): {first: number, last: number} {\n  const {data, getItemCount, maxToRenderPerBatch, windowSize} = props;\n  const itemCount = getItemCount(data);\n  if (itemCount === 0) {\n    return prev;\n  }\n  const {offset, velocity, visibleLength} = scrollMetrics;\n\n  // Start with visible area, then compute maximum overscan region by expanding from there, biased\n  // in the direction of scroll. Total overscan area is capped, which should cap memory consumption\n  // too.\n  const visibleBegin = Math.max(0, offset);\n  const visibleEnd = visibleBegin + visibleLength;\n  const overscanLength = (windowSize - 1) * visibleLength;\n\n  // Considering velocity seems to introduce more churn than it's worth.\n  const leadFactor = 0.5; // Math.max(0, Math.min(1, velocity / 25 + 0.5));\n\n  const fillPreference =\n    velocity > 1 ? 'after' : velocity < -1 ? 'before' : 'none';\n\n  const overscanBegin = Math.max(\n    0,\n    visibleBegin - (1 - leadFactor) * overscanLength,\n  );\n  const overscanEnd = Math.max(0, visibleEnd + leadFactor * overscanLength);\n\n  const lastItemOffset = getFrameMetricsApprox(itemCount - 1).offset;\n  if (lastItemOffset < overscanBegin) {\n    // Entire list is before our overscan window\n    return {\n      first: Math.max(0, itemCount - 1 - maxToRenderPerBatch),\n      last: itemCount - 1,\n    };\n  }\n\n  // Find the indices that correspond to the items at the render boundaries we're targeting.\n  let [overscanFirst, first, last, overscanLast] = elementsThatOverlapOffsets(\n    [overscanBegin, visibleBegin, visibleEnd, overscanEnd],\n    props.getItemCount(props.data),\n    getFrameMetricsApprox,\n  );\n  overscanFirst = overscanFirst == null ? 0 : overscanFirst;\n  first = first == null ? Math.max(0, overscanFirst) : first;\n  overscanLast = overscanLast == null ? itemCount - 1 : overscanLast;\n  last =\n    last == null\n      ? Math.min(overscanLast, first + maxToRenderPerBatch - 1)\n      : last;\n  const visible = {first, last};\n\n  // We want to limit the number of new cells we're rendering per batch so that we can fill the\n  // content on the screen quickly. If we rendered the entire overscan window at once, the user\n  // could be staring at white space for a long time waiting for a bunch of offscreen content to\n  // render.\n  let newCellCount = newRangeCount(prev, visible);\n\n  while (true) {\n    if (first <= overscanFirst && last >= overscanLast) {\n      // If we fill the entire overscan range, we're done.\n      break;\n    }\n    const maxNewCells = newCellCount >= maxToRenderPerBatch;\n    const firstWillAddMore = first <= prev.first || first > prev.last;\n    const firstShouldIncrement =\n      first > overscanFirst && (!maxNewCells || !firstWillAddMore);\n    const lastWillAddMore = last >= prev.last || last < prev.first;\n    const lastShouldIncrement =\n      last < overscanLast && (!maxNewCells || !lastWillAddMore);\n    if (maxNewCells && !firstShouldIncrement && !lastShouldIncrement) {\n      // We only want to stop if we've hit maxNewCells AND we cannot increment first or last\n      // without rendering new items. This let's us preserve as many already rendered items as\n      // possible, reducing render churn and keeping the rendered overscan range as large as\n      // possible.\n      break;\n    }\n    if (\n      firstShouldIncrement &&\n      !(fillPreference === 'after' && lastShouldIncrement && lastWillAddMore)\n    ) {\n      if (firstWillAddMore) {\n        newCellCount++;\n      }\n      first--;\n    }\n    if (\n      lastShouldIncrement &&\n      !(fillPreference === 'before' && firstShouldIncrement && firstWillAddMore)\n    ) {\n      if (lastWillAddMore) {\n        newCellCount++;\n      }\n      last++;\n    }\n  }\n  if (\n    !(\n      last >= first &&\n      first >= 0 &&\n      last < itemCount &&\n      first >= overscanFirst &&\n      last <= overscanLast &&\n      first <= visible.first &&\n      last >= visible.last\n    )\n  ) {\n    throw new Error(\n      'Bad window calculation ' +\n        JSON.stringify({\n          first,\n          last,\n          itemCount,\n          overscanFirst,\n          overscanLast,\n          visible,\n        }),\n    );\n  }\n  return {first, last};\n}\n\nconst VirtualizeUtils = {\n  computeWindowedRenderLimits,\n  elementsThatOverlapOffsets,\n  newRangeCount,\n};\n\nmodule.exports = VirtualizeUtils;\n"]}]}