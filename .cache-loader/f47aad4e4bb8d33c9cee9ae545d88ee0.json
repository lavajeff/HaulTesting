{"remainingRequest":"/Users/jeffrey/HaulTesting/node_modules/thread-loader/dist/cjs.js??ref--5-1!/Users/jeffrey/HaulTesting/node_modules/babel-loader/lib/index.js??ref--5-2!/Users/jeffrey/HaulTesting/node_modules/react-native-code-push/package-mixins.js","dependencies":[{"path":"/Users/jeffrey/HaulTesting/node_modules/react-native-code-push/package-mixins.js","mtime":1539745230847},{"path":"/Users/jeffrey/HaulTesting/node_modules/cache-loader/dist/cjs.js","mtime":1539652983212},{"path":"/Users/jeffrey/HaulTesting/node_modules/thread-loader/dist/cjs.js","mtime":1539652983315},{"path":"/Users/jeffrey/HaulTesting/node_modules/babel-loader/lib/index.js","mtime":1539615827828}],"contextDependencies":[],"result":["var _interopRequireDefault=require(\"@babel/runtime/helpers/interopRequireDefault\");var _regenerator=_interopRequireDefault(require(\"@babel/runtime/regenerator\"));var _objectSpread2=_interopRequireDefault(require(\"@babel/runtime/helpers/objectSpread\"));var _extends2=_interopRequireDefault(require(\"@babel/runtime/helpers/extends\"));var _reactNative=require(\"react-native\");var _RestartManager=_interopRequireDefault(require(\"./RestartManager\"));var _logging=_interopRequireDefault(require(\"./logging\"));module.exports=function(NativeCodePush){var remote=function remote(reportStatusDownload){return{download:function download(downloadProgressCallback){var downloadProgressSubscription,codePushEventEmitter,updatePackageCopy,downloadedPackage;return _regenerator.default.async(function download$(_context){while(1){switch(_context.prev=_context.next){case 0:if(this.downloadUrl){_context.next=2;break;}throw new Error(\"Cannot download an update without a download url\");case 2:if(downloadProgressCallback){codePushEventEmitter=new _reactNative.NativeEventEmitter(NativeCodePush);downloadProgressSubscription=codePushEventEmitter.addListener(\"CodePushDownloadProgress\",downloadProgressCallback);}_context.prev=3;updatePackageCopy=(0,_extends2.default)({},this);Object.keys(updatePackageCopy).forEach(function(key){return typeof updatePackageCopy[key]==='function'&&delete updatePackageCopy[key];});_context.next=8;return _regenerator.default.awrap(NativeCodePush.downloadUpdate(updatePackageCopy,!!downloadProgressCallback));case 8:downloadedPackage=_context.sent;if(reportStatusDownload){reportStatusDownload(this).catch(function(err){(0,_logging.default)(\"Report download status failed: \"+err);});}return _context.abrupt(\"return\",(0,_objectSpread2.default)({},downloadedPackage,local));case 11:_context.prev=11;downloadProgressSubscription&&downloadProgressSubscription.remove();return _context.finish(11);case 14:case\"end\":return _context.stop();}}},null,this,[[3,,11,14]]);},isPending:false};};var local={install:function install(){var installMode,minimumBackgroundDuration,updateInstalledCallback,localPackage,localPackageCopy,_args2=arguments;return _regenerator.default.async(function install$(_context2){while(1){switch(_context2.prev=_context2.next){case 0:installMode=_args2.length>0&&_args2[0]!==undefined?_args2[0]:NativeCodePush.codePushInstallModeOnNextRestart;minimumBackgroundDuration=_args2.length>1&&_args2[1]!==undefined?_args2[1]:0;updateInstalledCallback=_args2.length>2?_args2[2]:undefined;localPackage=this;localPackageCopy=(0,_extends2.default)({},localPackage);_context2.next=7;return _regenerator.default.awrap(NativeCodePush.installUpdate(localPackageCopy,installMode,minimumBackgroundDuration));case 7:updateInstalledCallback&&updateInstalledCallback();if(installMode==NativeCodePush.codePushInstallModeImmediate){_RestartManager.default.restartApp(false);}else{_RestartManager.default.clearPendingRestart();localPackage.isPending=true;}case 9:case\"end\":return _context2.stop();}}},null,this);},isPending:false};return{local:local,remote:remote};};",{"version":3,"sources":["/Users/jeffrey/HaulTesting/node_modules/react-native-code-push/package-mixins.js"],"names":["module","exports","NativeCodePush","remote","reportStatusDownload","download","downloadProgressCallback","downloadUrl","Error","codePushEventEmitter","NativeEventEmitter","downloadProgressSubscription","addListener","updatePackageCopy","Object","keys","forEach","key","downloadUpdate","downloadedPackage","catch","err","local","remove","isPending","install","installMode","codePushInstallModeOnNextRestart","minimumBackgroundDuration","updateInstalledCallback","localPackage","localPackageCopy","installUpdate","codePushInstallModeImmediate","RestartManager","restartApp","clearPendingRestart"],"mappings":"4UAAA,yCACA,wEACA,0DAKAA,MAAM,CAACC,OAAP,CAAiB,SAACC,cAAD,CAAoB,CACnC,GAAMC,CAAAA,MAAM,CAAG,QAATA,CAAAA,MAAS,CAACC,oBAAD,CAA0B,CACvC,MAAO,CACCC,QADD,mBACUC,wBADV,kNAEE,KAAKC,WAFP,8BAGK,IAAIC,CAAAA,KAAJ,CAAU,kDAAV,CAHL,QAOH,GAAIF,wBAAJ,CAA8B,CACtBG,oBADsB,CACC,GAAIC,gCAAJ,CAAuBR,cAAvB,CADD,CAG5BS,4BAA4B,CAAGF,oBAAoB,CAACG,WAArB,CAC7B,0BAD6B,CAE7BN,wBAF6B,CAA/B,CAID,CAdE,gBAmBKO,iBAnBL,CAmByB,sBAAc,EAAd,CAAkB,IAAlB,CAnBzB,CAoBDC,MAAM,CAACC,IAAP,CAAYF,iBAAZ,EAA+BG,OAA/B,CAAuC,SAACC,GAAD,QAAU,OAAOJ,CAAAA,iBAAiB,CAACI,GAAD,CAAxB,GAAkC,UAAnC,EAAkD,MAAOJ,CAAAA,iBAAiB,CAACI,GAAD,CAAnF,EAAvC,EApBC,kDAsB+Bf,cAAc,CAACgB,cAAf,CAA8BL,iBAA9B,CAAiD,CAAC,CAACP,wBAAnD,CAtB/B,SAsBKa,iBAtBL,eAwBD,GAAIf,oBAAJ,CAA0B,CACxBA,oBAAoB,CAAC,IAAD,CAApB,CACCgB,KADD,CACO,SAACC,GAAD,CAAS,CACd,uDAAsCA,GAAtC,EACD,CAHD,EAID,CA7BA,8DA+BWF,iBA/BX,CA+BiCG,KA/BjC,4BAiCDX,4BAA4B,EAAIA,4BAA4B,CAACY,MAA7B,EAAhC,CAjCC,kGAqCLC,SAAS,CAAE,KArCN,CAAP,CAuCD,CAxCD,CA0CA,GAAMF,CAAAA,KAAK,CAAG,CACNG,OADM,0PACEC,WADF,kDACgBxB,cAAc,CAACyB,gCAD/B,CACiEC,yBADjE,kDAC6F,CAD7F,CACgGC,uBADhG,qCAEJC,YAFI,CAEW,IAFX,CAGJC,gBAHI,CAGe,sBAAc,EAAd,CAAkBD,YAAlB,CAHf,oDAIJ5B,cAAc,CAAC8B,aAAf,CAA6BD,gBAA7B,CAA+CL,WAA/C,CAA4DE,yBAA5D,CAJI,SAKVC,uBAAuB,EAAIA,uBAAuB,EAAlD,CACA,GAAIH,WAAW,EAAIxB,cAAc,CAAC+B,4BAAlC,CAAgE,CAC9DC,wBAAeC,UAAf,CAA0B,KAA1B,EACD,CAFD,IAEO,CACLD,wBAAeE,mBAAf,GACAN,YAAY,CAACN,SAAb,CAAyB,IAAzB,CACD,CAXS,0DAcZA,SAAS,CAAE,KAdC,CAAd,CAiBA,MAAO,CAAEF,KAAK,CAALA,KAAF,CAASnB,MAAM,CAANA,MAAT,CAAP,CACD,CA7DD","sourcesContent":["import { NativeEventEmitter } from \"react-native\";\nimport RestartManager from \"./RestartManager\";\nimport log from \"./logging\";\n\n// This function is used to augment remote and local\n// package objects with additional functionality/properties\n// beyond what is included in the metadata sent by the server.\nmodule.exports = (NativeCodePush) => {\n  const remote = (reportStatusDownload) => {\n    return {\n      async download(downloadProgressCallback) {\n        if (!this.downloadUrl) {\n          throw new Error(\"Cannot download an update without a download url\");\n        }\n\n        let downloadProgressSubscription;\n        if (downloadProgressCallback) {\n          const codePushEventEmitter = new NativeEventEmitter(NativeCodePush);\n          // Use event subscription to obtain download progress.\n          downloadProgressSubscription = codePushEventEmitter.addListener(\n            \"CodePushDownloadProgress\",\n            downloadProgressCallback\n          );\n        }\n\n        // Use the downloaded package info. Native code will save the package info\n        // so that the client knows what the current package version is.\n        try {\n          const updatePackageCopy = Object.assign({}, this);\n          Object.keys(updatePackageCopy).forEach((key) => (typeof updatePackageCopy[key] === 'function') && delete updatePackageCopy[key]);\n\n          const downloadedPackage = await NativeCodePush.downloadUpdate(updatePackageCopy, !!downloadProgressCallback);\n\n          if (reportStatusDownload) {\n            reportStatusDownload(this)\n            .catch((err) => {\n              log(`Report download status failed: ${err}`);\n            });\n          }\n\n          return { ...downloadedPackage, ...local };\n        } finally {\n          downloadProgressSubscription && downloadProgressSubscription.remove();\n        }\n      },\n\n      isPending: false // A remote package could never be in a pending state\n    };\n  };\n\n  const local = {\n    async install(installMode = NativeCodePush.codePushInstallModeOnNextRestart, minimumBackgroundDuration = 0, updateInstalledCallback) {\n      const localPackage = this;\n      const localPackageCopy = Object.assign({}, localPackage); // In dev mode, React Native deep freezes any object queued over the bridge\n      await NativeCodePush.installUpdate(localPackageCopy, installMode, minimumBackgroundDuration);\n      updateInstalledCallback && updateInstalledCallback();\n      if (installMode == NativeCodePush.codePushInstallModeImmediate) {\n        RestartManager.restartApp(false);\n      } else {\n        RestartManager.clearPendingRestart();\n        localPackage.isPending = true; // Mark the package as pending since it hasn't been applied yet\n      }\n    },\n\n    isPending: false // A local package wouldn't be pending until it was installed\n  };\n\n  return { local, remote };\n};"]}]}